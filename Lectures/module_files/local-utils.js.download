G = sfig.serverSide ? global : this;

G.bestColor = 'red';
G.bestColorFunc = red;
G.altColor = 'purple';
G.altColorFunc = purple;
G.altTwoColor = 'orange';
G.altTwoColorFunc = orange;
G.testColor = 'gray';
G.testColorFunc = gray;
colorLatexMacro('bestColor', G.bestColor);
colorLatexMacro('altColor', G.altColor);
colorLatexMacro('altTwoColor', G.altTwoColor);

G.posColor = 'orange';
G.posColorFunc = orange;
G.negColor = 'blue';
G.negColorFunc = blue;
G.yColor = function (y) { return y === 1 ? posColor : negColor; }
G.yColorFunc = function (y) { return y === 1 ? posColorFunc : negColorFunc; }
colorLatexMacro('posColor', G.posColor);
colorLatexMacro('negColor', G.negColor);

G.muColor = 'purple';
G.muColorFunc = purple;
G.zColor = 'red';
G.zColorFunc = red;
G.xColor = 'green';
G.xColorFunc = green;
colorLatexMacro('muColor', G.muColor);
colorLatexMacro('zColor', G.zColor);
colorLatexMacro('xColor', G.xColor);

latexMacro('TrainLossMax', 0, '\\TrainLoss_\\text{max}');

G.titleImage = function() {
  return globalImage('learning.png').width(300);
}

G.sign = function(x) {
  return x > 0 ? 1 : -1;
}

G.sum = function(l) {
  let sum = 0;
  for (let x of l) {
    sum += x;
  }
  return sum;
}

G.mean = function(l) {
  return sum(l) / l.length;
}

G.vecAdd = function(a, b) {
  const c = [];
  for (let i = 0; i < a.length; i++) {
    c[i] = a[i] + b[i];
  }
  return c;
}

G.vecSub = function(a, b) {
  return vecAdd(a, scalarVecMul(-1, b));
}

G.dot = function(a, b) {
  let sum = 0;
  for (let i = 0; i < a.length; i++) {
    sum += a[i] * b[i];
  }
  return sum;
}

G.norm = function(a) {
  return Math.sqrt(dot(a, a));
}

G.scalarVecMul = function(c, l) {
  return l.map((x) => c * x);
}

G.rotate90 = function(w) {
  return [w[1], -w[0]];
}

G.round2 = function(x) {
  return round(x, 2);
}

G.vstr = function(l) {
  return `[${l.map(round2)}]`;
}

G.wstr = function(w) {
  return `$\\red{[${w.map(round2)}]}$`;
}

G.repeat = function(f, w, n) {
  for (let i = 0; i < n; i++) {
    w = f(w);
  }
  return w;
}

////////////////////////////////////////////////////////////
// linear-regression

G.kiwiPoints = [
  [1, 1],
  [2, 3],
  [4, 3],
];

G.kiwiBestF = function(x) {
  return x * kiwiBestF.slope + kiwiBestF.intercept;
}
kiwiBestF.intercept = 1;
kiwiBestF.slope = 0.57;

G.kiwiAltF = function(x) {
  return x * kiwiAltF.slope + kiwiAltF.intercept;
}
kiwiAltF.intercept = 2
kiwiAltF.slope = 0.2;

G.kiwiBestW = `[${kiwiBestF.intercept}, ${kiwiBestF.slope}]`;
G.kiwiAltW = `[${kiwiAltF.intercept}, ${kiwiAltF.slope}]`;

function process(info) {
  // Add additional fields (the prediction function f and the string representation wstr)
  info.f = (x) => dot(info.w, info.phi(x));
  info.wstr = vstr(info.w);
  return info;
}

// For non-linear features
G.kiwiSquaredPhi = x => [1, x, x*x];
G.kiwiSquared1 = process({
  phi: kiwiSquaredPhi,
  w: [2, 1, -0.2],
});
G.kiwiSquared2 = process({
  phi: kiwiSquaredPhi,
  w: [4, -1, 0.1],
});
G.kiwiSquared3 = process({
  phi: kiwiSquaredPhi,
  w: [1, 1, 0],
});

G.kiwiHistPhi = x => wholeNumbers(5).map(i => i < x && x <= i + 1 ? 1 : 0);
G.kiwiHist1 = process({
  phi: kiwiHistPhi,
  w: [1, 2, 4, 4, 3],
});
G.kiwiHist2 = process({
  phi: kiwiHistPhi,
  w: [4, 3, 3, 2, 1.5],
});

G.kiwiComboPhi = x => [1, x, x*x, Math.cos(3*x)];
G.kiwiCombo1 = process({
  phi: kiwiComboPhi,
  w: [1, 1, -0.1, 1],
});
G.kiwiCombo2 = process({
  phi: kiwiComboPhi,
  w: [3, -1, 0.1, 0.5],
});

G.kiwiGraph = function(opts) {
  const trajectories = [];
  const colors = [];
  if (opts.bestF) {
    trajectories.push([[0, kiwiBestF(0)], [5, kiwiBestF(5)]]);
    colors.push(bestColor);
  }
  if (opts.altF) {
    trajectories.push([[0, kiwiAltF(0)], [5, kiwiAltF(5)]]);
    colors.push(altColor);
  }
  const xs = linspace(0, 5, 100);
  if (opts.squaredF) {
    trajectories.push(xs.map((x) => [x, kiwiSquared1.f(x)]));
    colors.push(bestColor);
    trajectories.push(xs.map((x) => [x, kiwiSquared2.f(x)]));
    colors.push(altColor);
    trajectories.push(xs.map((x) => [x, kiwiSquared3.f(x)]));
    colors.push(altTwoColor);
  }
  if (opts.histF) {
    trajectories.push(xs.map((x) => [x, kiwiHist1.f(x)]));
    colors.push(bestColor);
    trajectories.push(xs.map((x) => [x, kiwiHist2.f(x)]));
    colors.push(altColor);
  }
  if (opts.comboF) {
    trajectories.push(xs.map((x) => [x, kiwiCombo1.f(x)]));
    colors.push(bestColor);
    trajectories.push(xs.map((x) => [x, kiwiCombo2.f(x)]));
    colors.push(altColor);
  }

  const graph = new sfig.LineGraph(trajectories);
  graph.xlength(300);
  graph.xrange(0, 5).yrange(0, 4);
  graph.trajectoryColors(colors);
  graph.roundPlaces(0).tickIncrValue(1);
  graph.axisLabel('$x$', '$y$');

  const points = opts.data ? overlay(...kiwiPoints.map(([x, y]) => {
    return circle(5).color('green').shift(graph.xvalueToCoord(x), graph.yvalueToCoord(y));
  })) : nil();

  Math.seedrandom(2);
  const complexPoints = opts.complexData ? overlay(...linspace(0, 5, 20).map((x) => {
    const y = kiwiSquared1.f(x) + Math.random();
    return circle(5).color('green').shift(graph.xvalueToCoord(x), graph.yvalueToCoord(y));
  })) : nil();

  const residualBlocks = kiwiPoints.map(([x, y]) => {
    return line(
      [graph.xvalueToCoord(x), graph.yvalueToCoord(y)],
      [graph.xvalueToCoord(x), graph.yvalueToCoord(kiwiBestF(x))],
    ).strokeWidth(2).dashed();
  });
  if (opts.residualLabel) {
    residualBlocks[0] = withRight(residualBlocks[0], terminology('residual'));
  }
  const residuals = opts.residuals ? overlay(...residualBlocks) : nil();

  const prediction = opts.prediction ?
    circle(5).strokeColor('gray').strokeWidth(2).shift(graph.xvalueToCoord(3), graph.yvalueToCoord(kiwiBestF(3))) :
    nil();

  return overlay(
    graph,
    points,
    complexPoints,
    residuals,
    prediction,
  ).scale(0.8);
}

G.kiwiDataTable = function() {
  return frameBox(table(['$x$', '$y$'], ...kiwiPoints.map(xy => xy.map(s => green('' + s)))).margin(30, 0));
}

G.kiwiTrainLossPlot = function() {
  function computeTotalLoss(intercept, slope) {
    let sum = 0;
    kiwiPoints.forEach(([x, y]) => {
      const loss = Math.pow(intercept + slope * x - y, 2);
      sum += loss;
    });
    return sum;
  }

  if (sfig.serverSide) {
    return localImage('trainLossPlot.png');
  }
  const width = 700;
  const height = 370;
  return rawAddHtml(width, height, (container) => {
    const interceptList = [];
    const slopeList = [];
    const lossList = [];
    const R = 1;
    for (const intercept of linspace(-R, R, 20)) {
      for (const slope of linspace(-R, R, 20)) {
        interceptList.push(intercept);
        slopeList.push(slope);
        lossList.push(computeTotalLoss(intercept, slope));
      }
    }

		const data = [{
      x: interceptList,
      y: slopeList,
      z: lossList,
      intensity: lossList,
      type: 'mesh3d',
      colorscale: [
        [0, 'rgb(0, 0, 255)'],
        [0.5, 'rgb(0, 255, 0)'],
        [1, 'rgb(255, 0, 0)'],
      ],
    }];

		const layout = {
      opacity: 0.8,
			//title: 'Loss',
			autosize: false,
      scene: {
        xaxis: {title: 'w1'},
        yaxis: {title: 'w2'},
        zaxis: {title: 'TrainLoss(w)'},
      },
			width: width,
			height: height,
			margin: { l: 65, r: 50, b: 65, t: 90, }
		};
		Plotly.newPlot(container, data, layout);
  }).recMouseShowHide(false);
}

G.kiwiPointsWithLosses = kiwiPoints.map(([x, y]) => {
  const loss = Math.pow(kiwiBestF.intercept + kiwiBestF.slope * x - y, 2);
  return [x, y, loss];
});
G.kiwiTrainLoss = mean(kiwiPointsWithLosses.map(([x, y, loss]) => loss));

////////////////////////////////////////////////////////////
// linear-classification

G.mangoPoints = [
  [[0, 2], 1],
  [[-2, 0], 1],
  [[1, -1], -1],
];

G.carPoints = [
  [[0, 2], 1],
  [[2, 0], 1],
  [[0, 0], -1],
  [[2, 2], -1],
];

G.mangoBestF = function(x) {  // Best weight vector
  return sign(dot(x, mangoBestF.w));
}
mangoBestF.w = [-0.6, 0.6];

G.mangoAltF = function(x) {
  return sign(dot(x, mangoAltF.w));
}
mangoAltF.w = [0.5, 1];

G.mangoBestW = vstr(mangoBestF.w);
G.mangoAltW = vstr(mangoAltF.w);

G.mangoGraph = function(opts) {
  const trajectories = [];
  const colors = [];
  if (opts.bestF) {
    const d = rotate90(mangoBestF.w);
    trajectories.push([scalarVecMul(-5, d), scalarVecMul(5, d)]);
    colors.push(bestColor);
  }
  if (opts.altF) {
    const d = rotate90(mangoAltF.w);
    trajectories.push([scalarVecMul(-3, d), scalarVecMul(3, d)]);
    colors.push(altColor);
  }
  const range = 3;
  const graph = new sfig.LineGraph(trajectories);
  graph.xlength(250).ylength(250);
  graph.xrange(-range, range).yrange(-range, range);
  graph.trajectoryColors(colors);
  graph.roundPlaces(0).tickIncrValue(1);
  if (opts.phi) {
    graph.axisLabel('$\\phi(x)_1$', '$\\phi(x)_2$');
  } else {
    graph.axisLabel('$x_1$', '$x_2$');
  }

  // weight vectors are normal to the decision boundary
  const normals = [];
  if (opts.bestF) {
    const w = mangoBestF.w;
    normals.push(arrow(
      graph.xyValueToCoord([0, 0]),
      graph.xyValueToCoord(w),
    ).strokeWidth(2).color(bestColor));
    if (opts.decisionBoundaryLabel) {
      normals.push(terminology('decision boundary').shift(graph.xvalueToCoord(2), graph.yvalueToCoord(2)));
    }
    if (opts.wPoint) {
      normals.push(circle(5).strokeColor(bestColor).shift(graph.xvalueToCoord(w[0]), graph.yvalueToCoord(w[1])));
    }
  }
  if (opts.altF) {
    const w = mangoAltF.w;
    normals.push(arrow(
      graph.xyValueToCoord([0, 0]),
      graph.xyValueToCoord(w),
    ).strokeWidth(2).color(altColor));
  }
  if (opts.carF) {
    // neural-networks (car example)
    normals.push(line(
      graph.xyValueToCoord([-range, -range + 1]),
      graph.xyValueToCoord([range - 1, range]),
    ).strokeWidth(2).color(bestColor));
    normals.push(arrow(
      graph.xyValueToCoord([0, 1]),
      graph.xyValueToCoord([-0.5, 1.5]),
    ).strokeWidth(2).color(bestColor));
    normals.push(line(
      graph.xyValueToCoord([-range + 1, -range]),
      graph.xyValueToCoord([range, range - 1]),
    ).strokeWidth(2).color(bestColor));
    normals.push(arrow(
      graph.xyValueToCoord([0, -1]),
      graph.xyValueToCoord([0.5, -1.5]),
    ).strokeWidth(2).color(bestColor));
    if (opts.hLabels) {
      normals.push(center('$\\red{h_1(x)}$').scale(0.8).shift(...graph.xyValueToCoord([1, -2])));
      normals.push(center('$\\red{h_2(x)}$').scale(0.8).shift(...graph.xyValueToCoord([-1, 2])));
    }
  }
  if (opts.circleF) {
    // non-linear-features
    const d = 0.5;  // Length of normal vector
    // Center of circle
    const cx = 1, cy = 1;
    // Radius of circle
    const r = Math.sqrt(2);
    const s = graph.xvalueToCoord(1) - graph.xvalueToCoord(0);  // value to coord conversion
    normals.push(circle(s * r).shift(graph.xvalueToCoord(cx), graph.yvalueToCoord(cy)).strokeWidth(2).strokeColor(altColor));
    normals.push(arrow(
      graph.xyValueToCoord([cx, cy-r]),
      graph.xyValueToCoord([cx, cy-r+d]),
    ).strokeWidth(2).color(altColor));
    normals.push(arrow(
      graph.xyValueToCoord([cx, cy+r]),
      graph.xyValueToCoord([cx, cy+r-d]),
    ).strokeWidth(2).color(altColor));
    normals.push(arrow(
      graph.xyValueToCoord([cx-r, cy]),
      graph.xyValueToCoord([cx-r+d, cy]),
    ).strokeWidth(2).color(altColor));
    normals.push(arrow(
      graph.xyValueToCoord([cx+r, cy]),
      graph.xyValueToCoord([cx+r-d, cy]),
    ).strokeWidth(2).color(altColor));
  }

  const points = opts.data ? overlay(...(opts.car ? carPoints : mangoPoints).map(([[x1, x2], y]) => {
    return circle(5).color(yColor(y)).shift(graph.xvalueToCoord(x1), graph.yvalueToCoord(x2));
  })) : nil();

  if (opts.dataVectors) {
    mangoPoints.forEach(([x, y]) => {
      normals.push(arrow(graph.xyValueToCoord([0, 0]), graph.xyValueToCoord(x)));
    });
  }

  const marginBlocks = mangoPoints.map(([x, y]) => {
    const projectedX = vecSub(x, scalarVecMul(dot(x, mangoAltF.w) / norm(x), mangoAltF.w));
    return line(
      graph.xyValueToCoord(x),
      graph.xyValueToCoord(projectedX),
    ).strokeWidth(2).dashed();
  });
  if (opts.marginLabel) {
    marginBlocks[0] = withRight(marginBlocks[0], terminology('margin'));
  }
  const margins = opts.margins ? overlay(...marginBlocks) : nil();

  const newX = [2, 0];
  const prediction = opts.prediction ?
    circle(5).strokeColor(yColor(mangoBestF(newX))).strokeWidth(2).shift(graph.xvalueToCoord(newX[0]), graph.yvalueToCoord(newX[1])) :
    nil();

  const axes = overlay(
    line(graph.xyValueToCoord([-range, 0]), graph.xyValueToCoord([range, 0])),
    line(graph.xyValueToCoord([0, -range]), graph.xyValueToCoord([0, range])),
  ).atomicMouseShowHide(true);

  return overlay(
    graph,
    axes,
    ...normals,
    points,
    margins,
    prediction,
  ).scale(0.8);
}

G.mangoDataTable = function(opts) {
  if (!opts) opts = {};
  const points = opts.carData ? carPoints : mangoPoints;
  const x1Label = opts.phi ? '$\\phi(x)_1$' : '$x_1$';
  const x2Label = opts.phi ? '$\\phi(x)_2$' : '$x_2$';
  const yLabel = opts.f ? '$f(x)$' : '$y$';
  return frameBox(table(
    [x1Label, x2Label, yLabel],
    ...points.map(([x, y]) => {
      return x.map(green).concat([yColorFunc(y)(y)]);
    }),
  ).margin(30, 0));
}

G.mangoPointsWithZeroOneLosses = mangoPoints.map(([x, y]) => {
  const loss = mangoAltF(x) != y ? 1 : 0;
  return [x, y, loss];
});
G.mangoZeroOneTrainLoss = mean(mangoPointsWithZeroOneLosses.map(([x, y, loss]) => loss));

G.mangoPointsWithHingeLossesAndGradients = mangoPoints.map(([x, y]) => {
  const loss = Math.max(1 - dot(mangoAltF.w, x) * y, 0);
  const margin = dot(mangoAltF.w, x) * y;
  const gradient = 1 - margin > 0 ? scalarVecMul(-y, x) : [0, 0];
  return [x, y, loss, gradient];
});

G.mangoHingeTrainLoss = mean(mangoPointsWithHingeLossesAndGradients.map(([x, y, loss, gradient]) => loss));
G.mangoHingeTrainLossGradient = scalarVecMul(1.0 / mangoPoints.length,
  mangoPointsWithHingeLossesAndGradients.map(([x, y, loss, gradient]) => gradient).reduce(vecAdd));

G.elephant = function() { return image('images/elephant.jpg').width(150); };
G.hummingbird = function() { return image('images/hummingbird.jpg').width(40); };
G.hummingbirds = function() {
  return table(
    [hummingbird(), hummingbird(), hummingbird()],
    [hummingbird(), hummingbird(), hummingbird()],
    [hummingbird(), hummingbird(), hummingbird()],
  );
}

////////////////////////////////////////////////////////////
// feature-templates

G.featureExtractionExample = function() {
  return parentCenter(overlay(
    xtable(
      withBottom(
        text(greenitalics('abc@gmail.com')).scale(0.8),
        '$x$',
      ),
      a = thickRightArrow(250),
      withBottom(
        frameBox(table(
          [red('length&gt;10'), ':', blue('1')],
          [red('fracOfAlpha'), ':', blue('0.85')],
          [red('contains_@'), ':', blue('1')],
          [red('endsWith_com'), ':', blue('1')],
          [red('endsWith_org'), ':', blue('0')],
        ).margin(5, 0)).scale(0.8),
        '$\\phi(x)$',
      ),
    ).center().margin(15),
    moveTopOf(purplebold('feature extractor $\\phi$'), a),
    moveBottomOf(purple('arbitrary!'), a),
  ));
}

G.featureTemplateExample = function() {
  return parentCenter(xtable(
    greenitalics('abc@gmail.com'),
    withBottom(
      thickRightArrow(450),
      'last three characters equals ___',
    ),
    frameBox(table(
      [red('endsWith_aaa'), ':', blue('0')],
      [red('endsWith_aab'), ':', blue('0')],
      [red('endsWith_aac'), ':', blue('0')],
      ['...', nil(), nil()],
      [red('endsWith_com'), ':', blue('1')],
      ['...', nil(), nil()],
      [red('endsWith_zzz'), ':', blue('0')],
    ).margin(5, 0)).scale(0.8),
  ).center().margin(15));
}

G.featureTemplateRow = function(description, example) {
  // Return table row with feature description and an example of concrete feature
  let concreteDescription = description;
  for (let value of example) {
    concreteDescription = concreteDescription.replace(/___/, greenitalics(value));
  }
  return [nowrapText(description), nowrapText(concreteDescription)];
}

////////////////////////////////////////////////////////////
// neural-networks

G.activationFunctionGraphs = function(opts) {
  const range = 5;
  const inputs = linspace(-range, range, 100);
  function threshold(z) { return z >= 0 ? 1 : 0; }
  function logistic(z) { return 1.0 / (1 + Math.exp(-z)); }
  function relu(z) { return Math.max(0, z); }

  const trajectories = [threshold, logistic, relu].map(act => inputs.map((x) => [x, act(x)]));
  const names = ['Threshold: $\\1[z \\ge 0]$', 'Logistic: $\\frac{1}{1 + e^{-z}}$', 'ReLU: $\\max(z, 0)$'].map(nowrapText);
  const colors = ['red', 'blue', 'orange'];

  const graph = new sfig.LineGraph(trajectories);
  graph.xrange(-range, range).yrange(0, range);
  graph.trajectoryNames(names);
  graph.trajectoryColors(colors);
  graph.xaxisLabel('$z = \\v_1 \\cdot \\phi(x)$');
  graph.yaxisLabel('$\\sigma(z)$');
  return xtable(graph.freeze(), graph.legend).margin(50).center();
}

G.squareBracket = function(x) {
  var px = 10, py = 2;
  var topLeft = [x.left().sub(px), x.top().up(py)];
  var bottomLeft = [x.left().sub(px), x.bottom().down(py)];
  var topRight = [x.right().add(px), x.top().up(py)];
  var bottomRight = [x.right().add(px), x.bottom().down(py)];
  var myline = function(a, b) { return line(a, b).strokeWidth(2); }
  return overlay(
    x,
    overlay(
      // Left
      myline(topLeft, bottomLeft),
      myline(topLeft, [topLeft[0].add(px/2), topLeft[1]]),
      myline(bottomLeft, [bottomLeft[0].add(px/2), bottomLeft[1]]),
      // Right
      myline(topRight, bottomRight),
      myline(topRight, [topRight[0].sub(px/2), topRight[1]]),
      myline(bottomRight, [bottomRight[0].sub(px/2), bottomRight[1]]),
    ).atomicMouseShowHide(true),
  _);
}

G.vectorBox = function(label, numRows, numCols, color, opts) {
  if (!numRows) numRows = 6;
  if (!numCols) numCols = 1;
  if (!color) color = 'red';
  if (!opts) opts = {};
  const cells = wholeNumbers(numRows).map(function() {
    return wholeNumbers(numCols).map(function() {
      return circle(10).fillColor(color).fillOpacity(0.5);
    });
  });
  // Show grouping of cells to highlight either rows or columns
  const extra = [];
  if (opts.highlightRows) {
    for (let r = 0; r < numRows; r++) {
      for (let c = 0; c < numCols - 1; c++) {
        extra.push(line(cells[r][c], cells[r][c + 1]));
      }
    }
  }
  if (opts.highlightCols) {
    for (let c = 0; c < numCols; c++) {
      for (let r = 0; r < numRows - 1; r++) {
        extra.push(line(cells[r][c], cells[r + 1][c]));
      }
    }
  }
  const box = frameBox(
    overlay(
      new Table(cells).margin(5),
      ...extra,
    ),
  ).padding(1).bg.strokeWidth(2).end.scale(0.6);

  return ytable(
    label ? std(label).orphan(true) : _,
    box,
  _).center().margin(5).atomicMouseShowHide(true);
}

G.vectorBox3D = function(label, numRows, numCols, numChannels, color) {
  const channels = [];
  for (let i = numChannels - 1; i >= 0; i--) {
    const c = i * 10;
    channels.push(opaquebg(vectorBox(i == 0 ? label : nil(), numRows, numCols, color)).shiftBy(c, c));
  }
  return overlay(...channels).atomicMouseShowHide(true);
}

////////////////////////////////////////////////////////////
// backpropgation

G.computationGraphAtoms = function() {
  return parentCenter(ytable(
    xtable(
      T(opPlus, C('1', Leaf('$a$')), C('1', Leaf('$b$'))),
      T(opMinus, C('1', Leaf('$a$')), C('-1', Leaf('$b$'))),
      T(opDot, C('b', Leaf('$a$')), C('a', Leaf('$b$'))),
    ).margin(100),
    xtable(
      T(opSquare, C('$2a$', Leaf('$a$'))),
      T(opMax, C('\\1[a > b]', Leaf('$a$')), C('\\1[a < b]', Leaf('$b$'))).recxmargin(200),
      T(opLogistic, C('$\\sigma(a) (1 - \\sigma(a))$', Leaf('$a$'))),
    ).margin(100),
  ).center().margin(50));
}

G.neuralNetworkGradientDiagram = function() {
  const h = T(opLogistic, C('$\\h \\circ (1-\\h)$', T(opDot, C('$\\phi(x)$', Leaf('$\\red{\\V}$')), Leaf('$\\phi(x)$'))));
  const score = T(opDot, C('$\\h$', Leaf('$\\red{\\w}$')), C('$\\w$', h));
  const residual = T(opMinus, C('1', score), Leaf('$y$'));
  const loss = T(opSquare, C('$2(\\text{residual})$', residual));
  return overlay(
    loss,
    moveLeftOf('$\\h$', h.headBox),
    moveLeftOf('score', score.headBox),
    moveLeftOf('residual', residual.headBox),
    moveLeftOf('loss', loss.headBox),
  _);
}

G.concreteLinearRegressionGradientDiagram = function() {
  const w = Leaf('$\\orange{\\w = [3, 1]}$');
  const phi = Leaf('$\\orange{\\phi(x) = [1, 2]}$');
  const y = Leaf('$\\orange{y = 2}$');
  const score = T(opDot, C('$\\phi(x) = [1, 2]$', w), phi);
  const residual = T(opMinus, C('1', score), y);
  const loss = T(opSquare, C('$2(\\text{residual})$', residual));
  score.xmargin(150);  // Need to do afterwards to override recmargin in T
  return overlay(
    loss,
    // Forward
    moveLeftOf(orange('score = 5'), score.headBox),
    moveLeftOf(orange('residual = 3'), residual.headBox),
    moveLeftOf(orange('loss = 9'), loss.headBox),
    // Backward
    moveRightOf(purple('[6, 12]'), w.headBox),
    moveRightOf(purple('6'), score.headBox),
    moveRightOf(purple('6'), residual.headBox),
    moveRightOf(purple('1'), loss.headBox),
  _);
}

////////////////////////////////////////////////////////////
// k-means

G.applePoints = [
  [[-2, 1], -1],
  [[0, 1], -1],
  [[-2, 3], -1],
  [[0, 3], -1],
  [[2, -1], +1],
  [[1, -2], +1],
  [[2, -3], +1],
  [[3, -2], +1],
];
G.appleCentroids = [
  [[-1, 2], -1],
  [[2, -2], +1],
];

G.appleDataTable = function(opts) {
  if (!opts) opts = {};
  return frameBox(table(
    ['$\\phi(x)_1$', '$\\phi(x)_2$'],
    ...applePoints.map(([x, y]) => {
      return x.map(green);
    }),
  ).margin(30, 0));
}

G.appleDataYTable = function(opts) {
  if (!opts) opts = {};
  return frameBox(table(
    ['$z$'],
    ...applePoints.map(([x, y]) => {
      return [yColorFunc(y)((y + 1) / 2 + 1)];
    }),
  ).margin(30, 0));
}

G.appleGraph = function(opts) {
  const trajectories = [];
  const colors = [];
  const range = 3;
  const graph = new sfig.LineGraph(trajectories);
  graph.xlength(250).ylength(250);
  graph.xrange(-range, range).yrange(-range, range);
  graph.trajectoryColors(colors);
  graph.roundPlaces(0).tickIncrValue(1);
  graph.axisLabel('$\\phi(x)_1$', '$\\phi(x)_2$');

  const points = [];
  const centroids = {};
  if (opts.centroids) {
    for (let [x, y] of appleCentroids) {
      const mu = center(square(7)).strokeWidth(3).strokeColor(yColor(y)).shift(...graph.xyValueToCoord(x));
      points.push(mu);
      centroids[y] = mu;
    }
  }
  if (opts.data) {
    for (let [x, y] of applePoints) {
      const c = opts.labeled ? yColor(y) : xColor;
      const p = circle(5).color(c).shift(...graph.xyValueToCoord(x));
      points.push(p);
      if (opts.links) {
        points.push(line(centroids[y], p).strokeWidth(2).dashed());
      }
    }
  }

  const axes = overlay(
    line(graph.xyValueToCoord([-range, 0]), graph.xyValueToCoord([range, 0])),
    line(graph.xyValueToCoord([0, -range]), graph.xyValueToCoord([0, range])),
  ).atomicMouseShowHide(true);

  return overlay(
    graph,
    axes,
    ...points,
  ).scale(0.8);
}

G.pancakeGraph = function(opts) {
  const points = [];
  const scale = 30;
  const range = 12;
  const height = 10;

  const data = [
    [0, -1],
    [2, -1],
    [10, 1],
    [12, 1],
  ];

  const axes = []
  axes.push(line([-scale, 0], [scale * (range + 1), 0]));
  for (let i = 0; i <= range; i++) {
    axes.push(line([scale * i, -height], [scale * i, +height]));
  }

  for (let [x, y] of data) {
    const p = circle(5).color(xColor).shiftBy(scale * x, 0);
    const q = withTop(
      p,
      std(x).scale(0.7),
    ).atomicMouseShowHide(true);
    axes.push(q);
    if (opts.zs) {
      points.push(moveBottomOf(std(zColorFunc(opts.zs[x])).scale(0.7), q));
    }
  }

  const centroids = [];
  for (let x of opts.mus) {
    const p = center(square(7).strokeWidth(3).strokeColor(muColor)).shiftBy(scale * x, 0);
    centroids.push(withTop(p, std(x).scale(0.7)).atomicMouseShowHide(true));
  }

  return parentCenter(overlay(
    overlay(...axes).atomicMouseShowHide(true),
    ...points,
    ...centroids,
  ));
}

G.formatClusters = function(clusters) {
  var i = 0;
  return parentCenter(ytable.apply(null, clusters.map(function(x) {
    i++;
    return nowrapText(stmt('Cluster '+i, x));
  })).scale(0.55).margin(2));
}

G.lossGraph = function(opts) {
  var zeroOneLoss = function(z) { return z <= 0 ? 1 : 0; };
  var hingeLoss = function(z) { return Math.max(0, 1 - z); };
  var logisticLoss = function(z) { return Math.log(1 + Math.exp(-z)); };
  var squaredLoss = function(z) { return 0.5 * z * z; };
  var absLoss = function(z) { return Math.abs(z); };

  function myPause(n) { return opts.pause ? pause(n) : _; }
  var range = 3;
  var trajectories = [];
  [zeroOneLoss, hingeLoss, logisticLoss, squaredLoss, absLoss].forEach(function(loss) {
    if (!opts.zeroOneLoss && loss == zeroOneLoss) return;
    if (!opts.hingeLoss && loss == hingeLoss) return;
    if (!opts.logisticLoss && loss == logisticLoss) return;
    if (!opts.squaredLoss && loss == squaredLoss) return;
    if (!opts.absLoss && loss == absLoss) return;

    var n = 60;
    var eps = 1e-4;
    var points = [];
    wholeNumbers(n+1).forEach(function(i) {
      var x = (i-n/2)/n * range * 2;
      points.push({x: x, y: loss(x - (opts.weights ? 1 : 0)) + (opts.weights ? 1 : 0)});
      if (x == 0 && loss == zeroOneLoss) points.push({x: x+eps, y: loss(x+eps)});
    });
    if (opts.pause) trajectories.push(myPause());
    trajectories.push(points);
  });

  if (opts.pause) trajectories.push(myPause());
  var names = [];
  var colors = [];
  if (opts.zeroOneLoss) { names.push('$\\ZeroOneLoss$'); colors.push('red'); }
  if (opts.hingeLoss) { names.push('$\\HingeLoss$'); colors.push('green'); }
  if (opts.logisticLoss) { names.push('$\\LogisticLoss$'); colors.push('orange'); }
  if (opts.squaredLoss) { names.push('$\\SquaredLoss$'); colors.push('brown'); }
  if (opts.absLoss) { names.push('$\\AbsLoss$'); colors.push('green'); }

  var graph = new sfig.LineGraph(trajectories);
  graph.trajectoryNames(names);
  if (opts.regression)
    graph.axisLabel('residual $(\\w \\cdot \\phi(x)) - y$', '$\\Loss(x, y, \\w)$');
  else if (opts.weights)
    graph.axisLabel('weight $\\w$', '$\\TrainLoss(\\w)$');
  else
    graph.axisLabel('margin $(\\w \\cdot \\phi(x)) y$', '$\\Loss(x, y, \\w)$');
  graph.trajectoryColors(colors);
  if (!opts.weights) {
    if (opts.legend) graph.legendPivot(4, 0);
    graph.ymaxValue(4);
  }
  graph.xrange(-range, range).yminValue(0).roundPlaces(0).tickIncrValue(1, opts.weights ? 2 : 1);
  return graph;
}


////////////////////////////////////////////////////////////
// group-dro

G.bananaPoints = [
  [1, 4, 'A'],
  [2, 8, 'A'],
  [5, 5, 'B'],
  [6, 6, 'B'],
  [7, 7, 'B'],
  [8, 8, 'B'],
];

G.bananaBestF = function(x) {
  return x * bananaBestF.slope + bananaBestF.intercept;
}
bananaBestF.intercept = 0;
bananaBestF.slope = 1.09;

G.bananaAltF = function(x) {
  return x * bananaAltF.slope + bananaAltF.intercept;
}
bananaAltF.intercept = 0;
bananaAltF.slope = 1.58;

G.bananaBestW = `[${bananaBestF.intercept}, ${bananaBestF.slope}]`;
G.bananaAltW = `[${bananaAltF.intercept}, ${bananaAltF.slope}]`;

G.aColor = 'orange';
G.aColorFunc = orange;
G.bColor = 'blue';
G.bColorFunc = blue;
G.gColor = function (g) { return g === 'A' ? aColor : bColor; }
G.gColorFunc = function (g) { return g === 'A' ? aColorFunc : bColorFunc; }
colorLatexMacro('aColor', G.aColor);
colorLatexMacro('bColor', G.bColor);

G.bananaDataTable = function() {
  return frameBox(table(['$x$', '$y$', '$g$'], ...bananaPoints.map(xyg => xyg.map(s => gColorFunc(xyg[2])(s)))).margin(30, 0));
}

G.bananaGraph = function(opts) {
  const trajectories = [];
  const colors = [];
  const xmax = 8, xmaxAlt = 6, ymax = 8;
  if (opts.bestF) {
    trajectories.push([[0, bananaBestF(0)], [xmax, bananaBestF(xmax)]]);
    colors.push(bestColor);
  }
  if (opts.altF) {
    trajectories.push([[0, bananaAltF(0)], [xmaxAlt, bananaAltF(xmaxAlt)]]);
    colors.push(altColor);
  }

  const graph = new sfig.LineGraph(trajectories);
  graph.xlength(300).ylength(250);
  graph.xrange(0, xmax).yrange(0, ymax);
  graph.trajectoryColors(colors);
  graph.roundPlaces(0).tickIncrValue(1);
  graph.axisLabel('$x$', '$y$');

  const points = opts.data ? overlay(...bananaPoints.map(([x, y, g]) => {
    return circle(5).color(gColor(g)).shift(graph.xvalueToCoord(x), graph.yvalueToCoord(y));
  })) : nil();

  const prediction = opts.prediction ?
    circle(5).strokeColor('gray').strokeWidth(2).shift(graph.xvalueToCoord(3), graph.yvalueToCoord(bananaBestF(3))) :
    nil();

  return overlay(
    graph,
    points,
    prediction,
  ).scale(0.8);
}

G.bananaPointsWithLosses = bananaPoints.map(([x, y, g]) => {
  const loss = Math.pow(bananaBestF.intercept + bananaBestF.slope * x - y, 2);
  return [x, y, loss];
});
G.bananaTrainLoss = mean(bananaPointsWithLosses.map(([x, y, loss]) => loss));

G.bananaAverageLossOnPoints = function(slope, points) {
  return mean(points.map(([x, y, g]) => {
    return Math.pow(x * slope - y, 2);
  }));
}

G.bananaAverageLoss = function(slope) {
  return bananaAverageLossOnPoints(slope, bananaPoints);
}

G.selectPointsByGroup = function(points, group) {
  return points.filter(([x, y, g]) => g === group);
}

G.bananaAPoints = selectPointsByGroup(bananaPoints, 'A');
G.bananaBPoints = selectPointsByGroup(bananaPoints, 'B');

G.bananaWorstCaseGroupLoss = function(slope) {
  const aLoss = bananaAverageLossOnPoints(slope, bananaAPoints);
  const bLoss = bananaAverageLossOnPoints(slope, bananaBPoints);
  return Math.max(aLoss, bLoss);
}

G.getMinPoint = function(points) {
  return points.reduce(([x1, f1], [x2, f2]) => {
    return f1 < f2 ? [x1, f1] : [x2, f2];
  });
}

G.bananaLossPlot = function(opts) {
  const names = [];
  const trajectories = [];
  const colors = [];
  const points = [];
  const wmax = 2, lossMax = 80;

  const ws = linspace(0, wmax, 100);
  if (opts.averageLoss) {
    const wLosses = ws.map((w) => [w, bananaAverageLoss(w)]);
    const minWLoss = getMinPoint(wLosses);
    console.log('average min', minWLoss);
    points.push({wLoss: minWLoss, color: bestColor});
    trajectories.push(wLosses);
    colors.push(bestColor);
    names.push('$\\TrainLoss$');
  }
  if (opts.aLoss) {
    const wLosses = ws.map((w) => [w, bananaAverageLossOnPoints(w, bananaAPoints)]);
    trajectories.push(wLosses);
    colors.push(aColor);
    names.push('$\\TrainLoss_\\aColor{\\text{A}}$');
  }
  if (opts.bLoss) {
    const wLosses = ws.map((w) => [w, bananaAverageLossOnPoints(w, bananaBPoints)]);
    trajectories.push(wLosses);
    colors.push(bColor);
    names.push('$\\TrainLoss_\\bColor{\\text{B}}$');
  }
  if (opts.worstCaseGroupLoss) {
    const wLosses = ws.map((w) => [w, bananaWorstCaseGroupLoss(w) + 1]);  // Add 1 to make it not overlap with A and B losses
    const minWLoss = getMinPoint(wLosses);
    console.log('worst-case group min', minWLoss);
    points.push({wLoss: minWLoss, color: altColor});
    trajectories.push(wLosses);
    colors.push(altColor);
    names.push('$\\TrainLossMax$');
  }

  const graph = new sfig.LineGraph(trajectories);
  graph.xlength(300).ylength(250);
  graph.xrange(0, wmax).yrange(0, lossMax);
  graph.trajectoryColors(colors);
  graph.trajectoryNames(names);
  graph.roundPlaces(0).tickIncrValue(1, 20);
  graph.legendPivot(-1, -1);
  graph.axisLabel('$\\w$', 'loss');

  function formatWLoss(w, loss) {
    return `w = ${round(w, 2)}, loss = ${round(loss, 2)}`;
  }

  return overlay(
    graph.freeze(), // graph.legend).margin(50),
    ...points.map(p => circle(5).color(p.color).shift(...graph.xyValueToCoord(p.wLoss)).tooltip(formatWLoss(...p.wLoss))),
  ).scale(0.8);
}


G.neuralNetwork = function(i, opts) {
  var myPause = i == 0 ? pause : function() { return _ };
  if (!opts) opts = {};
  return overlay(
    xtable(
      ytable(
        x1 = node(nil()),
        x2 = node(nil()),
        x3 = node(nil()),
      _).margin(20),
      ytable(
        h1 = node('$\\blue{\\sigma}$'),
        h2 = node('$\\blue{\\sigma}$'),
      _).margin(20),
      myPause(2),
      y = node(nil()),
    _).center().margin(150),
    myPause(-2),
    moveLeftOf(opts.rawx ? '$x_1$' : '$\\phi(x)_1$', x1),
    moveLeftOf(opts.rawx ? '$x_2$' : '$\\phi(x)_2$', x2),
    moveLeftOf(opts.rawx ? '$x_3$' : '$\\phi(x)_3$', x3),
    moveTopOf('$h_1$', h1),
    moveBottomOf('$h_2$', h2),
    a1 = arrow(x1, h1),
    moveTopOf('$\\red{\\V}$', a1),
    arrow(x1, h2),
    arrow(x2, h1),
    arrow(x2, h2),
    arrow(x3, h1),
    arrow(x3, h2),
    myPause(2),
    a2 = arrow(h1, y),
    arrow(h2, y),
    moveTopOf('$\\red{\\w}$', a2),
    moveRightOf(opts.out || '$\\text{score}$', y),
  _);
}

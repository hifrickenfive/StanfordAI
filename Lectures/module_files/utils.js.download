// General utilities for CS221.
// This file should only define functions.

G = sfig.serverSide ? global : this;

G.addProse = true;

sfig.wideScreen();

G.titleSlide = function(title) {
  if (!sfig.serverSide)
    document.title = 'CS221: Artificial Intelligence: ' + title;
  var s = slide.apply(null, arguments).showIndex(false);
  s.leftHeader(image('images/stanford-seal.png').dim(150));
  s.recMouseShowHide(false);  // No need to show gradually
  return s;
}

// Add a slide to the presentation
let lastId = 'begin';
const slideId2count = {};  // id -> number of slides that wanted to have that id (and as a result, they got '-<count>')
G.getUniqueSlideId = function(id) {
  const count = (slideId2count[id] || 0) + 1;
  slideId2count[id] = count;
  return id + (count == 1 ? '' : '-' + count);
}
const tagToSlides = {};  // tag => list of (js file, slideId)
G.add = function(block, tags) {
  // Add empty proses to make main slides always be on the LHS.
  if (addProse && prez.slides.length % 2 != 0) prose('');

  // Compute the id of the slide if it's not given
  let id = block.id().get();
  if (id == null) {
    // Try to grab it from the title
    const title = block.title().get();
    if (typeof(title) == 'string')
      id = title.toLowerCase().replace(/[^a-z\- ]/g, '').trim().replace(/ /g, '-').replace(/-+/g, '-');
  }
  if (id == null || id == '')  // Just use the last one
    id = lastId;
  block.id(getUniqueSlideId(id));
  lastId = id;

  // Add tags to the footer
  var footer = 'CS221';
  if (tags) {
    if (typeof(tags) == 'string') tags = [tags];
    footer += ' [' + tags.map(redbold) + ']';
    tags.forEach(function(tag) {
      var list = tagToSlides[tag];
      if (!list) list = tagToSlides[tag] = [];
      list.push([sfig_.urlParams.include, id]);
    });
  }
  block.leftFooter(nowrapText(footer).scale(0.8));

  // Add it!
  prez.addSlide(block);
  lastBlock = block;
}

G.initializeLecture = function() {
  sfig.initialize();
  if (sfig.serverSide) {
    var fs = require('fs');
    var path = sfig_.urlParams.include.replace(/\.js$/, '.tags.json');
    fs.writeFileSync(path, JSON.stringify(tagToSlides) + '\n');
  }
}

G.prose = function() {
  // Don't display proses in full screen
  if (sfig_.getDisplayMode() == sfig_.DISPLAYMODE_FULLSCREEN) return;

  // Don't display empty proses unless printing 1pp (so as to align things)
  if (arguments.length == 0) {
    if (sfig_.getDisplayMode() != sfig_.DISPLAYMODE_PRINT1PP) return;
  }

  // Sequence of strings or Blocks, separated by _
  var items = [];
  var itemStrings = [];  // Building up last item with strings.
  var flush = function() {
    if (itemStrings.length > 0) {
      items.push(bulletedText(itemStrings.join("\n")).fontSize(18));
      itemStrings = [];
    }
  }
  for (var i = 0; i < arguments.length; i++) {
    var x = arguments[i] || _;
    if (x == _) {
      flush();
    } else if (x instanceof sfig.Block) {
      flush();
      items.push(x);
    } else if (typeof(x) == 'string') {
      itemStrings.push(x);
    } else {
      throw 'Unhandled: ' + x;
    }
  }
  flush();
  var s = ytable.apply(null, items).margin(5);
  // Make the prose top-justified with the slides.
  // TODO: figure out how to do this without taking up a ton of space when the slide is below
  s = slide(null, s).border.color('white').end.showIndex(false);
  s.recMouseShowHide(false);
  s.id(getUniqueSlideId(lastId + '-prose'));
  prez.addSlide(s);
}

G.underConstruction = function() {
  add(slide(nil(), parentCenter(frameBox(bold('UNDER CONSTRUCTION')).bg.fillColor('#eed202').end), parentCenter('View at your own risk.')));
}

G.cite = function(ref, url) {
  return frame(ref).padding(3).bg.fillColor('red').fillOpacity(0.2).end.linkToUrl(url);
}

G.withCite = function(body, cite) {
  return ytable(text(cite).scale(0.5), body).xjustify('r');
}

G.modulebox = function(s) {
  return parentCenter(frameBox(nowrapText(s).width(800)).bg.strokeWidth(2).fillColor('#F3E8B6').end).atomicMouseShowHide(true);
}

G.terminology = function(s) {
  return text(brownbold(s)).scale(0.7).orphan(true);
}

////////////////////////////////////////////////////////////

// Key value store functions
G.keyValueCommand = function(command, args, callback) {
  var request = new XMLHttpRequest();
  request.open('GET', 'http://nimlet.nimaanari.com:7379/' + command + '/' + args.map(encodeURIComponent).join('/'));  // UPDATE
  if (sfig_.urlParams.auth)
    request.setRequestHeader("Authorization", "Basic " + btoa('cs221:' + sfig_.urlParams.auth));
  if (callback) {
    request.onload = function() {
      //alert(this.responseText);
      callback(JSON.parse(this.responseText));
    };
  }
  request.send();
}
G.delKey = function(key, callback) { keyValueCommand('DEL', [key], callback); }
G.getKey = function(key, callback) { keyValueCommand('GET', [key], function(result) { callback(result['GET']); }); }
G.setKeyValue = function(key, value, callback) { keyValueCommand('SET', [key, JSON.stringify(value)], callback); }
G.getKeyValues = function(key, callback) { keyValueCommand('HGETALL', [key], function(result) { callback(result['HGETALL']); }); }
G.incrKeyValue = function(key, value, incr, callback) { keyValueCommand('HINCRBY', [key, value, incr], callback); }
G.pushKeyValue = function(key, value, callback) { keyValueCommand('LPUSH', [key, JSON.stringify(value)], callback); }

G.smallButton = function(str) {
  return frame(str).padding(3).bg.fillColor('#F0F0D0').strokeWidth(1).round(5).end.setPointerWhenMouseOver().scale(0.5);
}

G.allowMultipleAnswers = function(question) { return question.match(/select all that apply/) != null; }

G.activateQuiz = function (id, question, answers) {
  setKeyValue('cs221-q', {id: id, question: question, answers: answers, allowMultipleAnswers: allowMultipleAnswers(question)});
  window.open('http://cs221.stanford.edu/q');
}
G.deactivateQuiz = function() {
  setKeyValue('cs221-q', {id: 'feedback', question: 'Do you have any comments about the class so far?'});
}

G.createMultipleChoiceQuiz = function(id, question, answers) {
  for (var i = 0; i < answers.length; i++)
    answers[i] = answers[i].toString();

  var ansBlocks = [];
  var counters = [];
  var selected_i = -1;
  var selected = [];
  var answerRows = []

  function unselect(decr) {
    if (selected_i != -1) {
      if (decr)
        incrKeyValue(id, answers[selected_i], -1);
      ansBlocks[selected_i].fillColor('white').updateElem();
      selected_i = -1;
      selected[selected_i] = false;
    }
  }
  function select(i) {
    selected_i = i;
    selected[selected_i] = true;
    incrKeyValue(id, answers[selected_i], +1);
    ansBlocks[selected_i].fillColor('#B9D48B').updateElem();
  }

  function setupAnswer(i) {
    var ansBlock = frameBox(text(answers[i]).width(600)).padding(5).bg.width(650).end;
    ansBlock.onClick(function() {
      if (allowMultipleAnswers(question)) {
        if (selected[i]) unselect(true);
        else select(i);
      } else {
        if (selected_i == i) return;
        unselect(true);
        select(i);
      }
    });
    ansBlock.setPointerWhenMouseOver();
    ansBlocks.push(ansBlock);
    var counter = wrap(nil());
    counters.push(counter);
    answerRows.push(xtable(frame(counter).pivot(1, 0).bg.width(80).end, ansBlock).center().margin(5));
  }

  for (var i = 0; i < answers.length; i++)
    setupAnswer(i);

  function reset() {
    // Clear histogram
    unselect(false);
    delKey(id, report);
  }

  function displayResults(value) {
    if (value == null) value = {};
    for (var i = 0; i < answers.length; i++)
      counters[i].content(text(value[answers[i]] || 0).color('brown'));
  }

  function report() {
    getKeyValues(id, function(value) {
      displayResults(value);
      prez.refresh();
    });
  }

  //if (showFeedback()) report();

  return ytable(
    ytable(
      question,
      ytable.apply(null, answerRows).margin(10),
    _).margin(20),
    xtable(
      sfig_.urlParams.auth ? smallButton('activate').onClick(function() { activateQuiz(id, question, answers); }) : _,
      sfig_.urlParams.auth ? smallButton('deactivate').onClick(deactivateQuiz) : _,
      sfig_.urlParams.auth ? smallButton('reset').onClick(reset) : _,
      sfig_.urlParams.auth ? smallButton('report').onClick(report) : _,
    _).margin(10),
  _).margin(20);
}

G.createFreeResponseQuiz = function(id, question) {
  var answerBox = textBox(80).fontSize(20).onEnter(function(textBox) {
    var value = textBox.content().get();
    incrKeyValue(id, value, 1);
  });
  var resultsBox = wrap(nil());

  function reset() { delKey(id, report); }
  function displayResults(response) {
    if (response == null) response = {};
    var items = [];
    // Add random noise to get a random permutation among elements with the same count.
    for (var key in response)
      items.push([response[key], key, Math.random() * 0.001]);
    items.sort(function(a, b) { return (b[0] + b[2]) - (a[0] + a[2]); });

    var n = items.length;
    for (var i = 0; i < n; i++)  // Remove randomnness
      items[i].pop();
    items = items.slice(0, 1000);  // Take only top 10

    if (n > items.length)
      items.push([n, '(total)']);
    if (items.length == 0)
      resultsBox.content('(no responses)');
    else
      resultsBox.content(new Table(items).xmargin(20).scale(0.8));
  }

  function report() {
    getKeyValues(id, function(value) {
      displayResults(value);
      prez.refresh();
    });
  }

  //if (showFeedback()) report();

  return ytable(
    ytable(
      question,
      indent(answerBox),
    _).margin(40),
    xtable(
      sfig_.urlParams.auth ? smallButton('activate').onClick(function() { activateQuiz(id, question); }) : _,
      sfig_.urlParams.auth ? smallButton('deactivate').onClick(deactivateQuiz) : _,
      sfig_.urlParams.auth ? smallButton('reset').onClick(reset) : _,
      sfig_.urlParams.auth ? smallButton('report').onClick(report) : _,
    _).margin(10),
    indent(resultsBox.scale(0.75)),
  _).margin(30);
}

G.quizSlide = function(id, question) {
  var answers = [];
  for (var i = 2; i < arguments.length; i++) {
    if (arguments[i] == _) continue;
    answers.push(arguments[i]);
  }
  var quiz;
  if (answers.length == 0)
    quiz = createFreeResponseQuiz(id, question);
  else
    quiz = createMultipleChoiceQuiz(id, question, answers);
  var s = slide('Question', quiz);
  s.leftHeader(xtable(image('images/question.jpg').width(70), text(redbold('answer in chat')).scale(1.5)).margin(5).center());
  //s.leftHeader(xtable(image('images/question.jpg').width(60)).margin(5).center());
  s.id('q-' + id);
  return s;
}

G.outlineSlide = function(title, sel, items) {
  var rows = [title];
  for (var i = 0; i < items.length; i++) {
    var id = items[i][0];
    var text = items[i][1];
    rows.push(roadmapItem(sel == i, text, id));
  }
  return roadmapSlide.apply(null, rows).id(items[sel][0]);
}

G.roadmapItem = function(active, text, id) {
  var b;
  if (active)
    b = parentCenter(frameBox(redbold(text)).bg.strokeWidth(3).end);
  else
    b = parentCenter(frameBox(text).bg.strokeColor('gray').end);
  if (id) b.setPointerWhenMouseOver(true).linkToInternal(prez, id, 0);
  return b;
}

G.moduleLink = function(text, id, image) {
  const b = parentCenter(frameBox(xtable(image ? image.width(50) : _, text).center().margin(10)).bg.strokeWidth(0).end.atomicMouseShowHide(true));
  b.linkToExternal('module', null, 0, {include: id});
  return b;
}

G.group = function(header, items) {
  return ytable(header, ...items).center();
}

G.evolutionOfModels = function(i, selectDescription) {
  add(slide('Course plan',
    nil(),
    getEvolutionOfModels(i, selectDescription),
  _));
}

G.getEvolutionOfModels = function(i, selectDescription) {
  function select(x) {
    x = std(x);
    if (selectDescription && x.content().get().match(selectDescription)) return frameBox(x).padding(5).bg.strokeWidth(4).end;
    return x;
  }
  var sub = function(x) { return select(text(x).scale(0.8)); };
  return parentCenter(overlay(
    ytable(
      selectPrefix(i, xtable,
        _, pause(),
        select(redbold('Reflex')),
        _, pause(),
        ytable(
          sub(green('Search problems')),
          sub(green('Markov decision processes')),
          sub(green('Adversarial games')),
          select(greenbold('States')),
        _).center().margin(10),
        _, pause(),
        ytable(
          sub(blue('Constraint satisfaction problems')),
          sub(blue('Markov networks')),
          sub(blue('Bayesian networks')),
          select(bluebold('Variables')),
        _).center().margin(10),
        _, pause(),
        select(purplebold('Logic')),
      _).margin(50).yjustify('r').scale(0.8),
      rightArrow(750).strokeWidth(5).showLevel(0),
      xtable(
        text('"Low-level intelligence"').scale(0.6),
        text('"High-level intelligence"').scale(0.6),
      _).margin(400).showLevel(0),
      _, pause(),
      select(text(brownbold('Machine learning'))).showLevel(i == 0 ? 1 : 0),
    _).center(),
  _)).recMouseShowHide(false);
}

G.dirname = function(path) {
  const tokens = path.split(/\//);
  return tokens.slice(0, tokens.length - 1).join('/');
}

G.globalImage = function(file) {
  const path = 'images/' + file;
  return parentCenter(image(path));
}

G.localImage = function(file) {
  // Look in the moduleGroup
  const path = dirname(sfig_.urlParams.include) + '/images/' + file;
  return parentCenter(image(path));
}

////////////////////////////////////////////////////////////
// General utilities

G.addTextLatexMacros = function(items) {
  items.forEach(function(x) { sfig.latexMacro(x, 0, '\\text{'+x+'}'); });
}

G.bigLeftArrow = function(s) { return leftArrow(s || 100).strokeWidth(10).color('brown'); }
G.bigRightArrow = function(s) { return rightArrow(s || 100).strokeWidth(10).color('brown'); }
G.bigUpArrow = function(s) { return upArrow(s || 100).strokeWidth(10).color('brown'); }
G.bigDownArrow = function(s) { return downArrow(s || 100).strokeWidth(10).color('brown'); }
G.bigUpDownArrow = function(s) { return upDownArrow(s || 100).strokeWidth(10).color('brown'); }
G.bigLeftRightArrow = function(s) { return leftRightArrow(s || 100).strokeWidth(10).color('brown'); }

G.dividerSlide = function(content) { return slide(null, nil(), std(content).recMouseShowHide(false)).titleHeight(0); }
G.summarySlide = function() { return slide.apply(null, arguments).leftHeader(image('images/summary.jpg').width(150)); }
G.roadmapSlide = function() { return slide.apply(null, arguments).leftHeader(image('images/signpost.jpeg').width(150)); }
G.announcementSlide = function() { return slide.apply(null, arguments).leftHeader(image('images/loudspeaker.jpg').width(150)); }

G.button = function(text) {
  return frame(text).bg.strokeWidth(2).round(10).fillColor('lightblue').end;
}

G.orElse = function(a, b) {
  return a != null ? a : b;
}

G.strToArray = function(str) { return str.split(''); }
G.strToMatrix = function(str) { return str.split('|').map(strToArray); }
G.mapVector = function(vector, func) {
  var newVector = [];
  for (var i = 0; i < vector.length; i++)
    newVector[i] = func(vector[i], i);
  return newVector;
}
G.mapMatrix = function(matrix, func) {
  return mapVector(matrix, function(row, r) {
    return mapVector(row, function(cell, c) { return func(cell, r, c); });
  });
}

// Mutates |target|.
G.mergeInto = function(target, source) {
  for (var key in source) target[key] = source[key];
  return target;
}

G.countOf = function(list, x) {
  var n = 0;
  for (var i = 0; i < list.length; i++)
    if (list[i] == x) n++;
  return n;
}

G.sumOf = function(list) {
  var n = 0;
  for (var i = 0; i < list.length; i++)
    n += list[i];
  return n;
}

G.round = function(x, n) {
  var base = Math.pow(10, n);
  return Math.round(x * base) / base;
}

G.zeros = function(n) {
  var result = [];
  for (var i = 0; i < n; i++) result[i] = 0;
  return result;
}

G.l2DistSquared = function(p, q) {
  var sum = 0;
  if (p.length != q.length) throw 'Mis-match: ' + p + ' and ' + q;
  for (var i = 0; i < p.length; i++) {
    var d = p[i] - q[i];
    sum += d * d;
  }
  return sum;
}

G.normalize = function(probs) {
  var sum = 0;
  for (var k = 0; k < probs.length; k++) sum += probs[k];
  if (sum == 0) {
    // Set to uniform
    for (var k = 0; k < probs.length; k++) probs[k] = 1.0 / probs.length;
    return false;
    //throw 'Bad: ' + probs;
  }
  for (var k = 0; k < probs.length; k++) probs[k] /= sum;
  return true;
}

G.sampleMultinomial = function(probs) {
  var v = Math.random();
  var sum = 0;
  for (var i = 0; i < probs.length; i++) {
    sum += probs[i];
    if (v < sum) return i;
  }
  throw 'Unable to sample from '+probs;
}

G.randint = function(n) {
  return Math.floor(Math.random() * n);
}

G.shuffle = function(l) {
  for (var i = 0; i < l.length-1; i++) {
    var j = Math.floor(Math.random() * (l.length-i)) + i;
    var tmp = l[i];
    l[i] = l[j];
    l[j] = tmp;
  }
}

G.sampleGaussian = function() {
  var u1 = Math.random();
  var u2 = Math.random();
  return Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
}

G.wholeNumbers = function(n) {
  var result = [];
  for (var i = 0; i < n; i++) result[i] = i;
  return result;
}

G.linspace = function(start, end, count) {
  const result = [];
  const step = (end - start) / (count - 1);
  for (let i = 0; i < count; i++) {
    result.push(start + (step * i));
  }
  return result;
}

G.randomChoice = function(list) {
  var i = Math.floor(Math.random() * list.length);
  return list[i];
}

G.l2Dist = function(v1, v2) {
  var sum = 0;
  if (v1.length != v2.length) throw 'Bad';
  for (var i = 0; i < v1.length; i++)
    sum += (v1[i]-v2[i]) * (v1[i]-v2[i]);
  return Math.sqrt(sum);
}

//// sfig utilities
G.maximizeWidth = function(b) { return transform(b).width(sfig.Text.defaults.getProperty('width')); }
G.indent = function(x, n) {
  n = n != null ? n : 20;
  // Adjust the width so it doesn't spill over
  var adjust = 30 + n;
  if (typeof(x) == 'string')
    x = text(x);
  if (x instanceof sfig.Text) {
    if (x.bulleted().get())
      adjust += 50;
    x.width(Text.defaults.getProperty('width').sub(adjust));
  }
  return frame(x).xpadding(n).xpivot(1);
}
G.indentNowrapText = function(x, n) {
  return indent(nowrapText(x), n);
}
G.bulletedTextNowrap = function(x) { return bulletedText(x).autowrap(false); }
G.xseq = function() { return new sfig.Table([arguments]).center().margin(5); }
G.yseq = function() { return ytable.apply(null, arguments).margin(10); }

G.stmt = function(prefix, suffix) {
  var m;
  if (!suffix && (m = prefix.match(/^([^:]+): (.+)$/))) {
    prefix = m[1];
    suffix = m[2];
  }
  return prefix.fontcolor('darkblue') + ':' + (suffix ? ' '+suffix : '');
}

G.blockquote = function(options) {
  var newWidth = 900;
  function setWidth(x) {
    if (x instanceof sfig.Text && x.width().getOrElse(newWidth) > newWidth) x.width(newWidth);
    if (x.children) x.children.forEach(setWidth);
  }
  var title = options.title;
  var contents = options.contents.map(function(x) {
    if (x == _) return x;
    x = std(x);
    setWidth(x);
    return x;
  });
  return parentCenter(frame(ytable.apply(null, contents)).padding(15, 10).bg.strokeWidth(2).end.title(opaquebg(title).atomicMouseShowHide(true)));
}

G.assumption = function(title) { return blockquote({title: xtable(image('images/assumption.jpg').width(50), redbold('Assumption: '+title)).center().margin(10), contents: Array.prototype.slice.call(arguments).slice(1)}); }
G.definition = function(title) { return blockquote({title: xtable(image('images/dictionary.jpg').width(50), greenbold('Definition: '+title)).center().margin(10), contents: Array.prototype.slice.call(arguments).slice(1)}); }
G.proposition = function(title) { return blockquote({title: xtable(image('images/purple-orb.jpg').width(50), bluebold('Proposition: '+title)).center().margin(10), contents: Array.prototype.slice.call(arguments).slice(1)}); }
G.theorem = function(title) { return blockquote({title: xtable(image('images/purple-orb.jpg').width(50), bluebold('Theorem: '+title)).center().margin(10), contents: Array.prototype.slice.call(arguments).slice(1)}); }
G.keyIdea = function(title) { return blockquote({title: xtable(image('images/light-bulb.jpg').width(50), redbold('Key idea: '+title)).margin(10).center(), contents: Array.prototype.slice.call(arguments).slice(1)}); }
G.example = function(title) { return blockquote({title: xtable(image('images/dodecahedron.jpg').width(50), orangebold('Example: '+title)).margin(10).center(), contents: Array.prototype.slice.call(arguments).slice(1)}); }
G.problem = function(title) { return blockquote({title: xtable(image('images/puzzle.jpg').width(50), orangebold('Problem: '+title)).margin(10).center(), contents: Array.prototype.slice.call(arguments).slice(1)}); }

G.algorithm = function(title) { return blockquote({title: xtable(image('images/algorithm.jpg').width(50), bluebold('Algorithm: '+title)).margin(10).center(), contents: Array.prototype.slice.call(arguments).slice(1)}); }
G.generativeModel = function(title) { return blockquote({title: xtable(image('images/generative.jpg').width(50), bluebold('Probabilistic program: '+title)).margin(10).center(), contents: Array.prototype.slice.call(arguments).slice(1)}); }
G.pseudocode = function(title) { return blockquote({title: xtable(image('images/algorithm.jpg').width(50), bluebold('Algorithm: '+title)).margin(10).center(), contents: interpretCode(Array.prototype.slice.call(arguments).slice(1))}); }

G.importantBox = function(title) { return blockquote({title: title, contents: Array.prototype.slice.call(arguments).slice(1)}); }

G.interpretCode = function(contents) {
  return contents.map(function(line) {
    if (typeof(line) == 'string') {
      var indent = line.length - line.replace(/^ */, '').length;
      var line = line.replace(/^(.*)(# .*)$/, '$1 <font color="blue"><em>$2</em></font>');
      return text('<tt>' + line.slice(0, indent).replace(/ /g, '&nbsp;') + line.slice(indent) + '</tt>').fontSize(18);
    }
    return line;
  });
}

G.headerList = function(title) {
  var contents = Array.prototype.slice.call(arguments).slice(1);
  return yseq.apply(null, [title ? stmt(title) : _].concat(contents.map(function(line) {
    if (line == _) return _;
    if (sfig.isString(line) || (!sfig.serverSide && line instanceof HTMLElement)) return bulletedText(line).autowrap(true);
    if (line instanceof sfig.Text && line.bulleted().get()) return line;
    if (line instanceof sfig.PropertyChanger) return line;
    if (line instanceof sfig.Overlay && line.items[0] instanceof sfig.Text && line.items[0].bulleted().get()) return line;
    return indent(line);
  })));
}

G.frameBox = function(content) { return frame(content).padding(10).bg.strokeWidth(1).end; }
G.labeledDownArrow = function(label, s) { return overlay(bigDownArrow(s || 80).strokeWidth(5), ytable(opaquebg(label), yline(15).strokeColor(sfig.defaultBgColor))).center().atomicMouseShowHide(true); }

G.stagger = function() {
  var items = [];
  var last_i = -1;
  for (var i = 0; i < arguments.length; i++) {
    if (arguments[i] == _) continue;
    var curr = arguments[i] = std(arguments[i]);
    if (curr instanceof sfig.PropertyChanger) {
      items.push(curr);
    } else {
      if (last_i != -1) {
        items.push(pause());
        arguments[last_i].numLevels(i - last_i);
      }
      items.push(curr);
      last_i = i;
    }
  }
  return overlay.apply(null, items);
}

G.smallUrl = function(description, url) {
  return text(bold(description) + ': ' + url).fontSize(16).linkToUrl(url);
}

G.applyIf = function(condition, func, arg) { return condition ? func(arg) : arg; }

// Return a moved to right of b.
G.moveLeftOf = function(a, b, offset) { return transform(a).pivot(1, 0).shift(b.left().sub(offset == null ? 5 : offset), b.ymiddle()); }
G.moveRightOf = function(a, b, offset) { return transform(a).pivot(-1, 0).shift(b.right().add(offset == null ? 5 : offset), b.ymiddle()); }
G.moveTopOf = function(a, b, offset) { return transform(a).pivot(0, 1).shift(b.xmiddle(), b.top().up(offset == null ? 5 : offset)); }
G.moveBottomOf = function(a, b, offset) { return transform(a).pivot(0, -1).shift(b.xmiddle(), b.bottom().down(offset == null ? 5 : offset)); }
G.moveCenterOf = function(a, b) { return transform(a).pivot(0, 0).shift(b.xmiddle(), b.ymiddle()); }
G.moveTopLeftOf = function(a, b, offset) { return transform(a).pivot(1, 1).shift(b.left().sub(offset == null ? 3 : offset), b.top().up(offset == null ? 3 : offset)); }
G.moveTopRightOf = function(a, b, offset) { return transform(a).pivot(-1, 1).shift(b.right().add(offset == null ? 3 : offset), b.top().up(offset == null ? 3 : offset)); }
G.moveBottomRightOf = function(a, b, offset) {
  // This is hacky because metapost bug that doesn't allow negative offsets.
  if (offset != null && offset < 0) {
    return transform(a).pivot(-1, -1).shift(b.right().sub(-offset), b.bottom().up(-offset));
  } else {
    return transform(a).pivot(-1, -1).shift(b.right().add(offset == null ? 3 : offset), b.bottom().down(offset == null ? 3 : offset));
  }
}

G.withLeft = function(thing, label, offset) { thing = std(thing); return overlay(thing.appendix(moveLeftOf(label, thing, offset).orphan(true))).closeAppendices(); }
G.withRight = function(thing, label, offset) { thing = std(thing); return overlay(thing.appendix(moveRightOf(label, thing, offset).orphan(true))).closeAppendices(); }
G.withTop = function(thing, label, offset) { thing = std(thing); return overlay(thing.appendix(moveTopOf(label, thing, offset).orphan(true))).closeAppendices(); }
G.withBottom = function(thing, label, offset) { thing = std(thing); return overlay(thing.appendix(moveBottomOf(label, thing, offset).orphan(true))).closeAppendices(); }
G.withCenter = function(thing, label) { thing = std(thing); return overlay(thing, moveCenterOf(label, thing, offset).orphan(true)); }

G.makeExpandButton = function() { return frameBox(text('+'.fontcolor('purple'))).bg.round(5).end.padding(-5).setPointerWhenMouseOver().scale(0.6).strokeColor('purple'); }
G.expandInternal = function(thing, prez, slideId, level) { thing = std(thing); return overlay(thing, moveRightOf(makeExpandButton().linkToInternal(prez, slideId, level), thing)); }
G.expandExternal = function(thing, name, slideId, level) { thing = std(thing); return overlay(thing, moveRightOf(makeExpandButton().linkToExternal(name, slideId, level), thing)); }
G.expandExplain = function(thing, content, options) {
  thing = std(thing);
  return overlay(thing, moveRightOf(explain(makeExpandButton(), content, mergeInto({pivot: [1,-1], borderWidth: 0}, options || {})), thing, options && options.margin));
}

G.youtube = function(id, options) {
  if (!options) options = {};
  var cacheVideos = options.cache != null ? options.cache : sfig_.urlParams.auth;
  var url;
  if (cacheVideos)
    url = 'cached-videos/'+id+'.'+(options.ext || 'mp4');
  else {
    //url = 'http://www.youtube.com/tv#/watch?v='+id;
    url = 'http://www.youtube.com/watch?v='+id;
    if (options.time)
      url += '&t='+options.time;
  }
  //return cachedImage('http://i1.ytimg.com/vi/'+id+'/default.jpg').width(200).linkToUrl(url);
  return cachedImage('images/'+id+'.jpg').width(200).linkToUrl(url);
}

G.svgDemo = function(path, width, height) {
  if (sfig.serverSide) {
    return image(path+'.png').width(width).height(height);
  }
  else{
    return '<object type="image/svg+xml" data="'+path+'" width="'+width+'" height="'+height+'"/>';
  }
}

G.basename = function(path) {
  var tokens = path.split('/');
  return tokens[tokens.length-1];
}

G.linkToVideo = function(block, path) {
  //var cacheVideos = (window.location.protocol == 'file:');
  var cacheVideos = true;
  var url = cacheVideos ? 'cached-videos/'+basename(path) : path;
  return std(block).linkToUrl(url);
}

G.stateExample = function() {
  return frameBox(ytable.apply(null, arguments)).bg.round(10).strokeWidth(2).strokeColor('blue').end;
}

G.side = function(text, image, url) {
  if (url == _) url = null;
  if (typeof(image) == 'string') {
    if (!url) url = image;
    image = cachedImage(image);
  }
  if (!image.width().exists()) image.width(100);
  //if (!image.height().exists()) image.height(100);
  if (url) image.linkToUrl(url);
  return xtable(image, std(text).width(900)).margin(20).center().atomicMouseShowHide(true);
}

G.sideBySide = function(a, b, margin) {
  return parentCenter(xtable(a, b).center().margin(margin || 50));
}

G.makeButton = function(label, func) {
  return frame(label).bg.strokeWidth(2).fillColor('lightblue').round(5).end.onClick(func).setPointerWhenMouseOver(true);
}

G.arrayExists = function(arr, func) {
  for (var i = 0; i < arr.length; i++)
    if (func(arr[i])) return true;
  return false;
}

G.arrayForall = function(arr, func) {
  for (var i = 0; i < arr.length; i++)
    if (!func(arr[i])) return false;
  return true;
}

G.argmax = function(weights) {
  var best_i = -1;
  for (var i = 0; i < weights.length; i++) {
    if (best_i == -1 || weights[i] > weights[best_i]) best_i = i;
  }
  return best_i;
}

G.increment = function(a, i, v) { a[i] = (a[i] || 0) + v; }

G.thickRightArrow = function(len) { return rightArrow(len || 50).strokeWidth(5); }
G.thickDownArrow = function(len) { return downArrow(len || 50).strokeWidth(5); }

G.randInt = function(n) { return Math.floor(Math.random() * n); }

G.squared = function(x) { return x * x; }

G.rgb = function(r, g, b) { return 'rgb('+Math.round(r)+','+Math.round(g)+','+Math.round(b)+')'; }

G.paramsToUrl = function(params) {
  var pathname = window.location.pathname;
  var urlHash = sfig_.serializeUrlParams(params);
  var url = pathname + urlHash;
  return url;
}

// Return |func| applied to a subset of the rest of the arguments.
// The rest of the arguments are broken into sections delimited by _.
// Select the arguments as follows:
// - sections before |section| without pauses
// - |section|
G.selectPrefix = function(section, func) {
  var items = [];
  var currSection = 0;  // Current section
  for (var i = 2; i < arguments.length; i++) {
    var arg = arguments[i];
    if (arg == _) { currSection++; continue; }  // section divider
    if (currSection != section && arg instanceof sfig.PropertyChanger) continue;  // skip pauses in previous sections
    arg = std(arg);
    if (currSection > section && arg instanceof sfig.Block) arg.showLevel(-1);  // hide future sections
    items.push(arg);
  }
  return func.apply(null, items);
}

// Paradigm
G.modeling = function() { return redbold('Modeling'); }
G.inference = function() { return greenbold('Inference'); }
G.learning = function() { return bluebold('Learning'); }
G.paradigm = function () {
  return parentCenter(ytable(
    modeling(),
    xtable(inference(), learning()).margin(200),
  _).margin(200).center());
};

G.node = function(x, shaded) { return overlay(circle(20).fillColor(shaded ? 'lightgray' : 'white'), std(x || nil()).orphan(true)).center(); }

// Create a slide to produce a graph in a WSYWIG way
G.createGraphSlide = function() {
  var nodes = [];  // list of nodes
  var edges = [];  // list of [node, node] pairs
  var contents = wrap(nil());
  var prev_v = null;

  function refresh() {
    var items = [];
    nodes.forEach(function(v) { items.push(v); });
    edges.forEach(function(e) { items.push(arrow(e[0], e[1])); });
    contents.content(overlay.apply(null, items));
    prez.refresh();

    var output = '//////////////////////////////\n';
    output += 'var nodes = [], edges = [];\n';
    for (var i = 0; i < nodes.length; i++) {
      var v = nodes[i];
      output += 'nodes.push(node(nil()).shift(' + v.xshift().get() + ', ' + v.yshift().get() + '));\n';
    }
    for (var i = 0; i < edges.length; i++) {
      var v1 = edges[i][0];
      var v2 = edges[i][1];
      output += 'edges.push(arrow(nodes['+nodes.indexOf(v1)+'], nodes['+nodes.indexOf(v2)+']));';
    }
    console.log(output);
  }

  function nodeClick(v, ev) {
    //sfig.L('nodeClick');
    if (ev.shiftKey) {
      // Remove v
      nodes = keepIf(nodes, function(vv) { return v != vv; });
      edges = keepIf(edges, function(e) { return e[0] != v && e[1] != v; });
      refresh();
    } else {
      if (prev_v == null) {
        prev_v = v;
      } else {
        edges.push([prev_v, v]);
        refresh();
        prev_v = null;
      }
    }
    ev.stopPropagation();
  }

  // General function
  function keepIf(list, f) {
    var newList = [];
    for (var i = 0; i < list.length; i++)
      if (f(list[i]))
        newList.push(list[i]);
    return newList;
  }

  function canvasClick(block, ev) {
    //sfig.L('canvasClick');
    var pt = [ev.clientX - 9, ev.clientY - 9];
    if (prev_v == null) {
      // Add a new node
      var v = node(nil()).shift(pt[0], pt[1]).onClick(nodeClick).cursor('pointer');
      nodes.push(v);
    } else {
      // Move node
      prev_v.shift(pt[0], pt[1]);
      prev_v = null;
    }
    refresh();
  }

  return slide(null).extra(contents).onClick(canvasClick).cursor('crosshair');
}

////////////////////////////////////////////////////////////
// Search

G.nodeEdgeGraph = function(options) {
  var mathMode = options.mathMode;
  var directed = options.directed || false;  // Is this a directed graph?
  var nodeSize = options.nodeSize || 40;
  var targetEdgeDist = options.targetEdgeDist || 80;
  var initRandom = options.initRandom;
  var numTrials = options.numTrials || 20;  // Number of random restarts
  var numIters = options.numIters || 100;  // Number of gradient steps
  var labelScale = options.labelScale;
  var labelColor = options.labelColor;
  var labelDist = options.labelDist || 10;
  var maxWidth = options.maxWidth;
  var maxHeight = options.maxHeight;
  var positions = options.positions;

  // Some nodes come as strings, convert to blocks
  var strToNodeIndex = {};

  var nodes = [];
  var edges = [];
  function nodeIndex(o) {
    if (typeof(o) == 'number') return o;
    if (typeof(o) == 'string') {
      if (strToNodeIndex[o] == null) {
        strToNodeIndex[o] = nodes.length;
        nodes.push(text(mathMode ? '$'+o+'$' : o));
      }
      return strToNodeIndex[o];
    }

    for (var i = 0; i < nodes.length; i++) {
      if (nodes[i] == o) return i;
    }
    nodes.push(o);
    return nodes.length-1;
  }

  function parseEdge(edge) {
    if (typeof(edge) == 'string') edge = edge.split(' ');
    var i = nodeIndex(edge[0]);
    var j = nodeIndex(edge[1]);
    return [i, j, edge[2]];
  }

  // Standardize nodes and edges
  if (options.nodes) {
    for (var i = 0; i < options.nodes.length; i++)
      nodeIndex(options.nodes[i]);
  }
  if (options.edges) {
    for (var e = 0; e < options.edges.length; e++)
      edges.push(parseEdge(options.edges[e]));
  }

  var highlightNodes = options.highlightNodes || [];
  if (typeof(highlightNodes) == 'string') highlightNodes = highlightNodes.split(' ');
  for (var i = 0; i < highlightNodes.length; i++)
    highlightNodes[i] = nodeIndex(highlightNodes[i]);

  var highlightEdges = options.highlightEdges || [];
  if (typeof(highlightEdges) == 'string') highlightEdges = highlightEdges.split(' ');
  for (var i = 0; i < highlightEdges.length; i++)
    highlightEdges[i] = parseEdge(highlightEdges[i])

  // Constraints that the x-coordinates and y-coordinates have to be equal
  var xequal = options.xequal || [];
  var yequal = options.yequal || [];
  function parseEqual(list) {
    if (typeof(list) == 'string') list = list.split(' ');
    var value = null;
    var newList = [];
    list.forEach(function(item) {
      if (item[0] == '=') value = parseInt(item.slice(1));
      else newList.push(nodeIndex(item));
    });
    return {value: value, list: newList};
  }
  xequal = xequal.map(parseEqual);
  yequal = yequal.map(parseEqual);

  var n = nodes.length;

  if (!positions) {
    // How far the nodes should be
    var adj = [];
    for (var i = 0; i < n; i++) adj[i] = [];
    for (var e = 0; e < edges.length; e++) {
      var i = edges[e][0];
      var j = edges[e][1];
      if (i == j) continue;
      adj[Math.min(i, j)][Math.max(i, j)] = targetEdgeDist;
    }

    var best_xpoint = null;
    var best_ypoint = null;
    var best_objective = null;

    if (initRandom) Math.seedrandom(initRandom);
    else Math.seedrandom();

    for (var trial = 0; trial < numTrials; trial++) {
      var xpoint = [];
      var ypoint = [];
      var xgrad = [];
      var ygrad = [];

      // Intitialize
      var initNoise = 10;
      for (var i = 0; i < n; i++) {
        //xpoint[i] = Math.random() * initNoise;
        xpoint[i] = i * targetEdgeDist;  // Prefer linear layout
        ypoint[i] = Math.random() * initNoise;
      }

      for (var iter = 0; iter < numIters; iter++) {
        // Compute gradient
        var objective = 0;
        for (var i = 0; i < n; i++) xgrad[i] = ygrad[i] = 0;
        for (var i = 0; i < n; i++) {
          for (var j = i+1; j < n; j++) {
            var xi = xpoint[i], yi = ypoint[i];
            var xj = xpoint[j], yj = ypoint[j];
            var pd = Math.sqrt((xi-xj)*(xi-xj) + (yi-yj)*(yi-yj)); // Predicted distance

            var td = adj[i][j];
            var dx, dy;
            if (td == null) td = Math.max(pd, targetEdgeDist);

            var penalty = pd > td ? 1 : 3;  // Farther is okay, closer is not
            // Objective function: 0.5 (pd - td)^2
            dx = (pd - td) * (pd == 0 ? 1 : (xi - xj) / pd) * penalty;
            dy = (pd - td) * (pd == 0 ? 1 : (yi - yj) / pd) * penalty;
            objective += 0.5 * (pd - td) * (pd - td) * penalty;

            // Make sure spread isn't too much
            var penalty = 1;
            if (maxWidth != null) {
              var rx = Math.abs(xi - xj);
              if (rx > maxWidth) {
                objective += 0.5 * (rx - maxWidth) * (rx - maxWidth) * penalty;
                dx += (xi > xj ? 1 : -1) * (rx - maxWidth) * penalty;
              }
            }
            if (maxHeight != null) {
              var ry = Math.abs(yi - yj);
              if (ry > maxHeight) {
                objective += 0.5 * (ry - maxHeight) * (ry - maxHeight) * penalty;
                dy += (yi > yj ? 1 : -1) * (ry - maxHeight) * penalty;
              }
            }

            xgrad[i] += dx;
            xgrad[j] -= dx;
            ygrad[i] += dy;
            ygrad[j] -= dy;
          }
        }

        //sfig.L(objective, wholeNumbers(n).map(function(i) { return xpoint[i].toFixed(2)+','+ypoint[i].toFixed(2); }).join(' '));

        // Update current point with gradient
        var stepSize = 1.0 / Math.sqrt(iter+1);
        for (var i = 0; i < n; i++) {
          xpoint[i] -= stepSize * xgrad[i];
          ypoint[i] -= stepSize * ygrad[i];
        }

        // Enforce constraints
        function processEqual(coord, eq) {
          var value = eq.value;
          var list = eq.list;
          if (value == null) {
            var sum = 0;
            for (var a = 0; a < list.length; a++) sum += coord[list[a]];
            value = sum / eq.list.length;
          }
          for (var a = 0; a < list.length; a++) coord[list[a]] = value;
        }
        xequal.forEach(function(eq) { processEqual(xpoint, eq) });
        yequal.forEach(function(eq) { processEqual(ypoint, eq) });
      }

      //sfig.L(objective);
      //sfig.L(xpoint.join(' '), ypoint.join(' '));
      if (best_objective == null || objective < best_objective) {
        best_objective = objective;
        best_xpoint = [].concat(xpoint);
        best_ypoint = [].concat(ypoint);
      }
    }

    //sfig.L('best', best_objective);
    positions = options.positions = wholeNumbers(n).map(function(i) { return {x: best_xpoint[i], y: best_ypoint[i]}; });
  }
  if (positions.length != nodes.length)
    throw 'Positions should equal the number of nodes: ' + positions.length + ' ' + nodes.length;

  // Draw border around nodes
  for (var i = 0; i < nodes.length; i++) {
    var c = circle(nodeSize/2.0);
    if (highlightNodes.indexOf(i) != -1) c.strokeWidth(2).strokeColor('blue');
    nodes[i] = overlay(c, nodes[i].orphan(true)).center();
  }

  // Draw everything
  var items = [];
  for (var i = 0; i < nodes.length; i++)
    items.push(center(nodes[i]).shiftBy(positions[i].x, positions[i].y));
  for (var e = 0; e < edges.length; e++) {
    var i = edges[e][0];
    var j = edges[e][1];
    var label = edges[e][2];
    var edge = decoratedLine(nodes[i], nodes[j]).strokeWidth(2).drawArrow2(directed);
    if (label != null) {
      label = wrap(label);
      if (labelScale != null) label.scale(labelScale);
      if (labelColor != null) label.strokeColor(labelColor);
      edge.label(label);
      edge.line.labelDist(labelDist);
      var found = false;
      highlightEdges.forEach(function(hedge) {
        if (hedge[0] == edges[e][0] && hedge[1] == edges[e][1])
          found = true;
      });
      if (found) {
        edge.strokeWidth(3);
        edge.line.color('blue');
      }
    }
    items.push(edge);
  }

  // Save rendered objects
  options.getNode = function(s) { return nodes[nodeIndex(s)]; }

  return new sfig.Overlay(items);
}

G.labeledArrow = function(a, b, label, curve) {
  curve = curve || 0;
  var e = arrow(a, b).line.curve(curve).labelDist(curve).strokeWidth(2).end;
  if (curve == 0)
    return overlay(e, opaquebg(center(label)).scale(0.6).shift(e.xmiddle(), e.ymiddle()));
  // TODO: make this work
  return overlay(e, opaquebg(center(label)).scale(0.6).shift(e.line.xlabel(), e.line.ylabel()));
}

////////////////////////////////////////////////////////////
// CSPs and Markov networks

G.australiaRegions = ['WA', 'NT', 'Q', 'NSW', 'V', 'SA', 'T'];
G.australia = function(options) {
  var colors = options.colors || {};
  var domains = options.domains;
  var condition = options.condition;
  function node(label) {
    if (condition && (label == 'Q' || label == 'SA')) return nil();
    return factorNode(label, {color: colors[label]});
  }
  var wa = node('WA');
  var nt = node('NT');
  var q = node('Q');
  var sa = node('SA');
  var nsw = node('NSW');
  var v = node('V');
  var t = node('T');
  function edge(a, b) {
    if (condition && (b == q || b == sa)) return partialEdgeFactor(a, b);
    return edgeFactor(a, b);
  }

  // Space-separated list of colors which are acceptable (null means anything is okay)
  function feasibleSet(colors) {
    function box(set, color) {
      if (set == null || set.match(color)) return square(20).fillColor(color).fillOpacity(0.5);
      return square(20).opacity(0);
    }
    var r = box(colors, 'red');
    var g = box(colors, 'green');
    var b = box(colors, 'blue');
    return frame(xtable(r, g, b)).bg.strokeWidth(1).end;
  }

  // Domains
  var labels = _;
  if (domains) {
    labels = overlay(
      moveTopOf(feasibleSet(domains['WA']), wa),
      moveTopOf(feasibleSet(domains['NT']), nt),
      moveBottomOf(feasibleSet(domains['SA']), sa),
      options.partial ? _ : overlay(
        moveTopOf(feasibleSet(domains['Q']), q),
        moveTopOf(feasibleSet(domains['NSW']), nsw),
        moveRightOf(feasibleSet(domains['V']), v),
        moveRightOf(feasibleSet(domains['T']), t),
      _),
    _);
  }

  return overlay(
    wa.shiftBy(0, 0),
    nt.shiftBy(100, -50),
    sa.shiftBy(100, 50),
    edge(wa, nt),
    edge(wa, sa), edge(nt, sa),
    options.partial ? _ : overlay(
      q.shiftBy(200, -30),
      nsw.shiftBy(300, 50),
      v.shiftBy(200, 120),
      t.shiftBy(200, 200),
      edge(nt, q), edge(nsw, q),
      edge(nsw, sa), edge(v, sa),
      condition ? _ : edge(q, sa),
      edge(v, nsw),
    _),
    labels,
  _);
}

G.backtrackingTree = function(tree, options) {
  if (options == null) options = {};
  if (!(tree instanceof Array)) tree = [tree];
  var children = [];
  for (var i = 1; i < tree.length; i++) {
    if (options.pause) children.push(pause());
    children.push(backtrackingTree(tree[i], options));
  }
  var isStr = sfig.isString(tree[0]);
  var head = isStr ? text(tree[0]).scale(3) : australia({colors: tree[0], domains: tree[0].domains});
  var out = rootedTree.apply(null, [head].concat(children));
  if (isStr) out.nodeBorderWidth(0);
  else out.nodeBorderWidth(tree[0].highlight ? 10 : 3);
  out.nodePadding(10).margin(60, 60);
  out.drawArrow2(true).edgeStrokeWidth(3).verticalCenterEdges(true);
  return out;
}

G.standardAustraliaColors = {WA: 'red', NT: 'green', Q: 'red', SA: 'blue', NSW: 'green', V: 'red', T: 'green'};
G.coloredAustralia = function() {
  return australia({colors: standardAustraliaColors});
}

G.partlyColoredAustralia = function() {
  return australia({colors: {WA: 'red', NT: 'green', Q: 'red', SA: 'blue'}});
}

G.naryConstraint = function(n) {
  var f = square(20);
  var nodes = wholeNumbers(n).map(function(i) { return factorNode('$X_{'+(i+1)+'}$'); });
  var lines = wholeNumbers(n).map(function(i) { return line(f, nodes[i]); });
  return overlay(
    ytable(
      f,
      table(nodes).margin(20),
    _).center().margin(50),
    new Overlay(lines),
  _);
}

G.cspGraph = function(o) {
  return overlay(
    table(
      [a = circle(25), b = circle(25)],
      [c = o.eliminate ? nil() : circle(25), d = circle(25)],
    _).margin(60),
    moveCenterOf('$X_1$', a),
    moveCenterOf('$X_2$', b),
    o.eliminate ? _ : moveCenterOf('$X_3$', c),
    moveCenterOf('$X_4$', d),
    o.pause ? pause() : _,
    edgeFactor(a, b),
    edgeFactor(b, d),
    o.eliminate ? _ : overlay(e = edgeFactor(a, c), o.labelEdges ? moveLeftOf('$f_{13}$', e) : _),
    o.eliminate ? _ : overlay(e = edgeFactor(c, d), o.labelEdges ? moveBottomOf('$f_{34}$', e) : _),
    o.eliminate ? overlay(e = edgeFactor(a, d), o.labelEdges ? moveLeftOf('$f_{14}$', e.items[1]) : _) : _, // HACK
  _);
}

G.exampleFactorGraph = function() {
  function varNode(label) {
    return overlay(text(label).orphan(true), circle(25)).center().atomicMouseShowHide(true);
  }
  function consNode(label) {
    return overlay(text(label).orphan(true).scale(0.8), square(30)).center().atomicMouseShowHide(true);
  }
  return overlay(
    ytable(
      xtable(x1 = varNode('$X_1$'), x2 = varNode('$X_2$'), x3 = varNode('$X_3$')).xmargin(50),
      xtable(c1 = consNode('$f_1$'), c2 = consNode('$f_2$'), c3 = consNode('$f_3$'), c4 = consNode('$f_4$')).xmargin(50),
    _).center().ymargin(40),
    line(x1, c1).strokeWidth(2),
    line(x1, c2).strokeWidth(2), line(x2, c2).strokeWidth(2),
    line(x2, c3).strokeWidth(2), line(x3, c3).strokeWidth(2),
    line(x3, c4).strokeWidth(2),
  _);
}

G.australiaBacktrackingTree = function() {
  const tree = backtrackingTree([{},
    [{WA:'red'},
      {WA:'red', NT: 'red'},
      {WA:'red', NT: 'green'},
      {WA:'red', NT: 'blue'},
    ],
    [{WA:'green'},
      {WA:'green', NT: 'red'},
      {WA:'green', NT: 'green'},
      {WA:'green', NT: 'blue'},
    ],
    [{WA:'blue'},
      {WA:'blue', NT: 'red'},
      {WA:'blue', NT: 'green'},
      {WA:'blue', NT: 'blue'},
    ],
  ], {pause: false}).scale(0.25);

  const leaves = table(
    ['$\\vdots$', nil(), '$\\vdots$', nil(), '$\\vdots$'],
    [
      withBottom(backtrackingTree([{T: 'red', WA:'red', V:'red', Q:'red', NT:'green', SA: 'green', NSW: 'green'}]).scale(0.25), '0'),
      '$\\dots$',
      withBottom(backtrackingTree([{T: 'red', WA:'red', V:'red', Q:'red', NT:'red', SA: 'blue', NSW: 'green'}]).scale(0.25), '0'),
      '$\\dots$',
      withBottom(backtrackingTree([{T: 'red', WA:'red', V:'red', Q:'red', NT:'blue', SA: 'green', NSW: 'blue'}]).scale(0.25), '1'),
    ],
  ).margin(50).center();

  return ytable(tree, leaves).center().margin(50);
}

//// For drawing factor graphs

G.factorNode = function(label, options) {
  if (!options) options = {};
  var color = options.color || 'white';
  var c = circle(options.radius || 30);
  if (color == 'bold')
    c.strokeWidth(5);
  else
    c.fillColor(color).fillOpacity(0.5);
  if (!label) return c;
  return overlay(c, std(label).orphan(true)).center().atomicMouseShowHide(true);
}

G.squareFactor = function(options) {
  if (!options) options = {}
  var color = options.color || 'white';
  return square(10).fillColor(color); }

// Line between a and b with a square factor.
G.edgeFactor = function(a, b, opts) {
  var l = line(a, b);
  return overlay(l.strokeWidth(2), center(squareFactor(opts)).shift(l.xmiddle(), l.ymiddle()));
}

// Line from a to midpoint of a and b with a square factor.
// Think of conditioning on b
G.partialEdgeFactor = function(a, b) {
  var x = a.xmiddle().add(b.xmiddle()).div(2);
  var y = a.ymiddle().add(b.ymiddle()).div(2);
  return overlay(line(a, [x, y]).strokeWidth(2), center(squareFactor()).shift(x, y));
}

G.topEdgeFactor = function(a) {
  var sq = squareFactor();
  return overlay(
    moveTopOf(sq, a, 15),
    line(sq, a).strokeWidth(2),
  _);
}

G.leftEdgeFactor = function(a) {
  var sq = squareFactor();
  return overlay(
    moveLeftOf(sq, a, 15),
    line(sq, a).strokeWidth(2),
  _);
}

G.rightEdgeFactor = function(a) {
  var sq = squareFactor();
  return overlay(
    moveRightOf(sq, a, 15),
    line(sq, a).strokeWidth(2),
  _);
}

G.bottomEdgeFactor = function(a) {
  var sq = squareFactor();
  return overlay(
    moveBottomOf(sq, a, 15),
    line(sq, a).strokeWidth(2),
  _);
}

G.reviewFactorGraph = function() {
  return parentCenter(xtable(
    exampleFactorGraph().atomicMouseShowHide(true),
    definition('factor graph',
      stmt('Variables'),
      indent('$X = (X_1, \\dots, X_n)$, where $X_i \\in \\Domain_i$'),
      stmt('Factors'),
      indent('$f_1, \\dots, f_m$, with each $f_j(X) \\ge 0$'),
    ).scale(0.8),
  ).margin(50).center());
}

G.reviewAssignmentWeight = function(opts) {
  if (!opts) opts = {};

  const assignmentWeight = definition('assignment weight',
    'Each <b>assignment</b> $x = (x_1, \\dots, x_n)$ has a <b>weight</b>:',
    parentCenter('$\\displaystyle \\Weight(x) = \\prod_{j=1}^m f_j(x)$'),
  ).scale(0.8);

  if (!opts.objective) {
    return assignmentWeight;
  }

  let objective;
  if (opts.objective === 'csp') {
    objective = '$\\displaystyle \\arg\\max_{x} \\Weight(x)$';
  } else if (opts.objective === 'mrf') {
    objective = 'compute $\\P(X_i = x_i)$ for all $i$';
  }
  return parentCenter(xtable(
    assignmentWeight,
    ytable(stmt('Objective'), indent(objective)),
  ).center().margin(50));
}

////////////////////////////////////////////////////////////

G.objectTrackingGraph = function(opts) {
  if (!opts) opts = {};
  const trajectories = [];
  trajectories.push([[1, 1], [2, 1], [3, 2]]);
  if (!opts.onlyOneTrajectory) {
    trajectories.push([[1, 0], [2, 2], [3, 2]]);
  }
  const colors = ['orange', 'purple'];
  const graph = new sfig.LineGraph(trajectories);
  graph.xlength(300);
  graph.xrange(0, 4).yrange(0, 3);
  graph.trajectoryColors(colors);
  graph.roundPlaces(0).tickIncrValue(1);
  const positionVar = opts.positionVar || 'X';
  graph.axisLabel('time $i$', `position $${positionVar}_i$`);

  const observations = [
    [1, 0],
    [2, 2],
    [3, 2],
  ];
  const points = overlay(...observations.map(([x, y]) => {
    return circle(5).color('green').shift(graph.xvalueToCoord(x), graph.yvalueToCoord(y));
  }));

  return parentCenter(overlay(graph, points));
}

G.objectTrackingO1Factor = function() {
  return frameBox(table(
    ['$x_1$', '$o_1(x_1)$'],
    [0, 2],
    [1, 1],
    [2, 0],
  ).center().margin(10, 5));
}

G.objectTrackingO2Factor = function() {
  return frameBox(table(
    ['$x_2$', '$o_2(x_2)$'],
    [0, 0],
    [1, 1],
    [2, 2],
  ).center().margin(10, 5));
}

G.objectTrackingO3Factor = function() {
  return frameBox(table(
    ['$x_3$', '$o_3(x_3)$'],
    [0, 0],
    [1, 1],
    [2, 2],
  ).center().margin(10, 5));
}

G.objectTrackingTFactor = function() {
  return frameBox(table(
    ['$|x_i-x_{i+1}|$', '$t_i(x_i, x_{i+1})$'],
    [0, 2],
    [1, 1],
    [2, 0],
  ).center().margin(10, 5));
}

G.objectTrackingCSP = function() {
  return parentCenter(ytable(
    xtable(
      chainFactorGraph({n:3, observations: [0, 2, 2]}).scale(0.7).atomicMouseShowHide(true),
      objectTrackingO1Factor().scale(0.5).atomicMouseShowHide(true),
      objectTrackingO2Factor().scale(0.5).atomicMouseShowHide(true),
      objectTrackingO3Factor().scale(0.5).atomicMouseShowHide(true),
      objectTrackingTFactor().scale(0.5).atomicMouseShowHide(true),
    ).margin(50).center(),
    text('[demo]').linkToUrl('module.html#include=csps/inference-demo.js&example=track&postCode=maxVariableElimination()'),
  ).center().margin(20));
}

G.chainFactorGraph = function(opts) {
  var nodes = [];
  var xVar = opts.xVar || 'X';
  var start = (opts.start || 1) - 1;
  var end = (opts.end || opts.n) - 1;
  for (var i = start; i <= end; i++) {
    var selected = false;
    if (opts.xfocus != null)
      selected = opts.xfocus != (i+1);
    else if (opts.condition != null)
      selected = opts.condition == (i+1);
    var x = factorNode('$' + xVar + '_{'+(i+1)+'}$', selected ? {color: 'gray'} : null);
    if (selected && opts.remove) x.showLevel(-1);
    nodes[i] = x;
  }
  var edges = [];
  for (var i = start; i <= end; i++) {
    if (i < end) {
      var g = edgeFactor(nodes[i], nodes[i+1]);
      edges.push(g);
      if (opts.remove && i+2 == opts.condition)
        edges.push(moveTopOf('$t_{'+(i+1)+'}(\\cdot, 0)$', g).scale(0.6));
      else if (opts.remove && i+1 == opts.condition)
        edges.push(moveTopOf('$t_{'+(i+1)+'}(0, \\cdot)$', g).scale(0.6));
      else
        edges.push(moveTopOf('$t_{'+(i+1)+'}$', g).scale(0.8));
    }
    if (opts.remove && i+1 == opts.condition) continue;
    var h = bottomEdgeFactor(nodes[i]);
    edges.push(h);
    edges.push(moveRightOf('$o_{'+(i+1)+'}$', h).scale(0.8));
    edges.push(bottomEdgeFactor(nodes[i]));
    if (opts.observations) {
      edges.push(moveBottomOf(text(opts.observations[i]).strokeColor('green'), h));
    }
    if (opts.x && opts.x[i] != null) {
      edges.push(moveTopOf(text(opts.x[i]).strokeColor('purple'), nodes[i]));
    }
  }
  if (start > 0 && opts.forward) {
    var f = leftEdgeFactor(nodes[start]);
    edges.push(f);
    edges.push(moveLeftOf('$F_{'+(start+1)+'}$', f).scale(0.8));
  }
  if (end < opts.n-1) {
    var f = rightEdgeFactor(nodes[end]);
    edges.push(f);
    edges.push(moveRightOf('$t_{'+(end+1)+'}(\\cdot, 0)$', f).scale(0.8));
  }
  return overlay(
    xtable.apply(null, nodes.slice(start)).margin(40),
    new Overlay(edges),
  _);
}

////////////////////////////////////////////////////////////
// Bayesian networks

G.hmm = function(opts) {
  var myPause = opts.pause ? pause : function() { return _ };
  var xs = [];
  var es = [];
  var items = [];
  var lastx = null;
  var first = null;
  var hVar = opts.hVar || 'H';
  var oVar = opts.oVar || 'E';
  for (var i = 1; i <= opts.maxTime; i++) {
    var x = factorNode('$'+hVar+'_{'+i+'}$', opts.xfocus != null && opts.xfocus != i ? {color: 'gray'} : null);
    if (!first) first = x;
    xs.push(x);
    if (lastx != null) {
      var t = arrow(lastx, x);
      items.push(t);
    }
    if (opts.pause) items.push(pause());
    var e = factorNode('$'+oVar+'_{'+i+'}$', (opts.condition == null || opts.condition) ? {color: 'gray'} : null);
    es.push(e);
    var o = arrow(x, e);
    items.push(o);
    if (opts.observations) {
      items.push(moveBottomOf(text(green(opts.observations[i - 1])).scale(0.7), e));
    }
    if (opts.pause) items.push(pause(-1));
    lastx = x;
  }
  if (opts.values) {
    items.push(moveTopOf('(3,1)'.fontcolor('red'), xs[0]).scale(0.8));
    items.push(moveTopOf('(3,2)'.fontcolor('red'), xs[1]).scale(0.8));
  }
  if (opts.pause) items.push(pause());
  if (opts.values) {
    items.push(moveBottomOf('4'.fontcolor('red'), es[0]).scale(0.8));
    items.push(moveBottomOf('5'.fontcolor('red'), es[1]).scale(0.8));
  }
  return overlay(
    table(xs, myPause(), es).margin(50),
    myPause(-1),
    overlay.apply(null, items),
  _);
}

G.updateColor = function(block) {
  // Move into sfig some day
  if (block.elem) {
    block.elem.style.stroke = block.strokeColor().get();
    block.elem.style.fill = block.fillColor().get();
  }
}

G.twoLayerBayesNet = function(opts) {
  var nodes1 = wholeNumbers(opts.n1).map(function(i) { return factorNode(); });
  var nodes2 = wholeNumbers(opts.n2).map(function(i) { return factorNode(null, {color:'gray'}); });
  var edges = [];
  for (var i = 0; i < nodes1.length; i++)
    for (var j = 0; j < nodes2.length; j++)
      edges.push((opts.undirected ? line : arrow)(nodes1[i], nodes2[j]));
  return overlay(
    ytable(
      xtable.apply(null, nodes1).margin(50),
      xtable.apply(null, nodes2).margin(50),
    _).center().margin(200),
    new Overlay(edges),
    (opts.label ? moveLeftOf('$h$', nodes1[0]) : _),
    (opts.label ? moveLeftOf('$x$', nodes2[0]) : _),
  _);
}

G.smallGraph = function(opts) {
  function barrow(a, b) {
    const arr = arrow(a, b);
    if (opts.showPath) arr.strokeWidth(3).color('blue');
    return arr;
  }
  const nodes = [], edges = [];
  let start, goal;
  nodes.push(start = node(nil()).shift(43, 224));
  nodes.push(node(nil()).shift(126, 152));
  nodes.push(node(nil()).shift(127, 257));
  nodes.push(node(nil()).shift(195, 185));
  nodes.push(node(nil()).shift(213, 273));
  nodes.push(node(nil()).shift(274, 188));
  nodes.push(node(nil()).shift(314, 266));
  nodes.push(node(nil()).shift(350, 183));
  nodes.push(node(nil()).shift(443, 190));
  nodes.push(node(nil()).shift(198, 104));
  nodes.push(node(nil()).shift(391, 247));
  nodes.push(node(nil()).shift(344, 106));
  nodes.push(goal = node(nil()).shift(425, 118));
  edges.push(barrow(nodes[0], nodes[1]));
  edges.push(barrow(nodes[1], nodes[2]));
  edges.push(barrow(nodes[2], nodes[3]));
  edges.push(arrow(nodes[3], nodes[4]));
  edges.push(arrow(nodes[3], nodes[9]));
  edges.push(arrow(nodes[9], nodes[1]));
  edges.push(arrow(nodes[2], nodes[0]));
  edges.push(arrow(nodes[2], nodes[4]));
  edges.push(barrow(nodes[3], nodes[5]));
  edges.push(arrow(nodes[5], nodes[9]));
  edges.push(arrow(nodes[9], nodes[11]));
  edges.push(arrow(nodes[11], nodes[5]));
  edges.push(barrow(nodes[5], nodes[7]));
  edges.push(barrow(nodes[7], nodes[12]));
  edges.push(arrow(nodes[11], nodes[12]));
  edges.push(arrow(nodes[11], nodes[7]));
  edges.push(arrow(nodes[12], nodes[8]));
  edges.push(arrow(nodes[8], nodes[10]));
  edges.push(arrow(nodes[6], nodes[10]));
  edges.push(arrow(nodes[10], nodes[7]));
  edges.push(arrow(nodes[7], nodes[6]));
  edges.push(arrow(nodes[5], nodes[6]));
  edges.push(arrow(nodes[6], nodes[4]));
  edges.push(arrow(nodes[5], nodes[4]));
  edges.push(arrow(nodes[7], nodes[8]));
  start.items[0].strokeWidth(4).strokeColor('blue');
  goal.items[0].strokeWidth(4).strokeColor('blue');
  Math.seedrandom(5);
  const other = [];
  edges.forEach(e => {
    const t = opts.showWeights ? text(randInt(9)) : text('?').strokeColor('red');
    other.push(t.scale(0.5).shift(e.xmiddle(), e.ymiddle()));
  });
  return overlay.apply(null, nodes.concat(edges).concat(other)).scale(0.65);
}

////////////////////////////////////////////////////////////
// Logic

G.formulaSchema = function() { return rect(100, 10).fillColor('pink'); }

G.logicSchema = function(sel) {
  function high(func, str) {
    return !sel || sel.indexOf(str) == -1 ? func(bold(str)) : frameBox(func(bold(str))).strokeWidth(4).bg.fillColor('lightgray').end;
  }
  var syntax = overlay(
    ytable(
      f = formulaSchema(), formulaSchema(), formulaSchema(), formulaSchema(),
      formulaSchema(), formulaSchema(), formulaSchema(), formulaSchema(),
      a = bigDownArrow(140),
      g = formulaSchema(),
    _).center().margin(10),
    moveLeftOf('formula', f).scale(0.8),
    moveLeftOf(ytable(high(green, 'Inference'), high(green, 'rules')).center(), a),
    //moveRightOf(frameBox(ytable(bold('Inference'), bold('algorithm')).center()).strokeWidth(0), a),
  _);
  var semantics = overlay(
    rect(300, 350).round(10).strokeWidth(4),
    n = ellipse(120, 100).shiftBy(150, 200).fillColor('lightgreen'),
    m = ellipse(100, 50).shiftBy(150, 200).fillColor('lightblue'),
    moveTopOf('models', n).scale(0.8),
  _);
  return parentCenter(overlay(
    table(
      [high(red, 'Syntax'), high(blue, 'Semantics')],
      [syntax, semantics],
    _).center().margin(100, 20),
    arrow([f.right(), f.ymiddle()], m).strokeWidth(3),
    arrow([g.right(), g.ymiddle()], n).strokeWidth(3),
  _));
}
